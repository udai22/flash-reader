<!DOCTYPE html>
<!--
    High-Performance Flash Reader
    1) Single fetch of entire book text
    2) Event delegation (no per-word listeners)
    3) Single pass for chapters
    4) Throttled saves
    5) All the same features: speed reading, context view, chapters, undo, theme toggles, progress nav, etc.
-->
<html lang="en" data-theme="light">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>{{ book.title }} - Flash Reader</title>
  <style>
    /* -----------------------------------------------------------
       THEME VARIABLES
       ----------------------------------------------------------- */
    html[data-theme="light"] {
      --primary-color: #2563eb;
      --text-color: #1f2937;
      --bg-color: #f3f4f6;
      --surface-color: #ffffff;
      --progress-bg: rgba(37, 99, 235, 0.1);
      --progress-fill: rgba(37, 99, 235, 0.9);
      --button-bg: rgba(255, 255, 255, 0.9);
      --button-hover: #ffffff;
    }

    html[data-theme="dark"] {
      --primary-color: #60a5fa;
      --text-color: #e5e7eb;
      --bg-color: #111827;
      --surface-color: #1f2937;
      --progress-bg: rgba(96, 165, 250, 0.1);
      --progress-fill: rgba(96, 165, 250, 0.9);
      --button-bg: rgba(31, 41, 55, 0.9);
      --button-hover: #374151;
    }

    html[data-theme="sand"] {
      --primary-color: #9c4221;
      --text-color: #442c1d;
      --bg-color: #faf0e6;
      --surface-color: #fff8f0;
      --progress-bg: rgba(156, 66, 33, 0.1);
      --progress-fill: rgba(156, 66, 33, 0.9);
      --button-bg: rgba(255, 248, 240, 0.9);
      --button-hover: #fff8f0;
    }

    body {
      margin: 0;
      padding: 0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: var(--bg-color);
      color: var(--text-color);
      overflow: hidden; /* We'll toggle overflow when context is open */
      height: 100vh;
      width: 100vw;
      transition: background-color 0.3s, color 0.3s;
    }

    /* -----------------------------------------------------------
       THEME TOGGLE & WPM CONTROLS
       ----------------------------------------------------------- */
    .theme-toggle {
      position: fixed;
      right: 16px;
      top: 16px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      z-index: 10002;
    }

    .theme-buttons {
      display: flex;
      gap: 8px;
      background: var(--button-bg);
      padding: 4px;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }

    .theme-button {
      padding: 8px 12px;
      border: none;
      border-radius: 4px;
      background: transparent;
      color: var(--text-color);
      cursor: pointer;
      font-size: 14px;
      transition: background-color 0.2s;
    }
    .theme-button.active {
      background: var(--primary-color);
      color: #fff;
    }
    .theme-button:hover:not(.active) {
      background: var(--button-hover);
    }

    .wpm-controls {
      background: var(--button-bg);
      padding: 8px 12px;
      border-radius: 12px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .wpm-controls button {
      width: 44px;
      height: 44px;
      border: none;
      border-radius: 10px;
      background: var(--bg-color);
      color: var(--text-color);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
      position: relative;
      padding: 0;
    }
    .wpm-controls button svg {
      width: 20px;
      height: 20px;
      stroke-width: 2.5;
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
    }
    .wpm-controls button:active {
      background: var(--primary-color);
      color: #fff;
      transform: scale(0.95);
    }
    .wpm-controls .wpm-value {
      padding: 0 8px;
      font-weight: 600;
      font-size: 16px;
      color: var(--text-color);
      min-width: 90px;
      text-align: center;
      font-variant-numeric: tabular-nums;
    }

    .context-mode-button {
      margin-top: 8px;
      width: 100%;
      padding: 8px 12px;
      background: var(--button-bg);
      border: 1px solid var(--progress-bg);
      border-radius: 8px;
      color: var(--text-color);
      font-size: 14px;
      font-weight: 500;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }
    .context-mode-button:hover {
      background: var(--button-hover);
    }
    .context-mode-button.active {
      background: var(--primary-color);
      color: #fff;
      border-color: var(--primary-color);
    }

    /* -----------------------------------------------------------
       READER CONTAINER
       ----------------------------------------------------------- */
    .reader-container {
      position: relative;
      width: 100%;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    /* BACK BUTTON */
    .back-button {
      position: fixed;
      left: 16px;
      top: 16px;
      padding: 8px 16px;
      background: rgba(255, 255, 255, 0.9);
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-size: 14px;
      color: var(--text-color);
      z-index: 100;
    }
    .back-button:hover {
      background: #fff;
    }

    /* -----------------------------------------------------------
       PROGRESS BAR (LEFT)
       ----------------------------------------------------------- */
    .progress-bar {
      position: fixed;
      left: 0;
      top: 0;
      bottom: 0;
      width: 4px;
      background: var(--progress-bg);
      opacity: 0;
      transition: opacity 0.3s;
    }
    .progress-bar.visible {
      opacity: 1;
    }
    .progress-fill {
      position: absolute;
      bottom: 0;
      width: 100%;
      background: var(--progress-fill);
      transition: height 0.3s;
    }

    .progress-info {
      position: fixed;
      left: 16px;
      top: 16px;
      background: rgba(255, 255, 255, 0.9);
      padding: 8px 12px;
      border-radius: 8px;
      font-size: 14px;
      opacity: 0;
      transition: opacity 0.3s;
    }
    .progress-info.visible {
      opacity: 1;
    }

    /* -----------------------------------------------------------
       WORD DISPLAY (CENTER)
       ----------------------------------------------------------- */
    .word-boundary {
      position: relative;
      padding: 40px;
      border-radius: 12px;
      background: rgba(var(--bg-color-rgb), 0.1);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transform: translateZ(0);
      -webkit-backface-visibility: hidden;
      backface-visibility: hidden;
    }
    .word-display {
      font-size: 36px;
      font-weight: 500;
      text-align: center;
      user-select: none;
      transition: opacity 0.3s ease;
    }

    .context-view.visible ~ .word-boundary {
      display: none;
    }

    /* -----------------------------------------------------------
       CONTEXT VIEW (FULL TEXT)
       ----------------------------------------------------------- */
    .context-view {
      position: fixed;
      inset: 0;
      background: var(--surface-color);
      overflow-y: auto;
      visibility: hidden;
      opacity: 0;
      z-index: 9999;
      -webkit-overflow-scrolling: touch;
      height: 100vh;
      width: 100vw;
      transition: opacity 0.3s ease, visibility 0.3s;
      transform: translateZ(0);
      -webkit-backface-visibility: hidden;
      backface-visibility: hidden;
    }
    .context-view.visible {
      visibility: visible;
      opacity: 1;
    }

    .context-header {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: 60px;
      background: var(--surface-color);
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 16px;
      z-index: 10000;
      border-bottom: 1px solid var(--progress-bg);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
    }
    .context-close-button {
      padding: 8px 12px;
      background: var(--surface-color);
      border: 1px solid var(--progress-bg);
      border-radius: 8px;
      color: var(--text-color);
      font-size: 14px;
      font-weight: 500;
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
      margin-left: auto;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }
    .context-close-button:active {
      transform: scale(0.98);
      background: var(--button-hover);
    }
    .context-content {
      max-width: 800px;
      margin: 0 auto;
      line-height: 1.8;
      font-size: 18px;
      padding: 80px 20px 120px; /* space so content not hidden behind header */
      position: relative;
      background: var(--surface-color);
      min-height: calc(100vh - 60px);
      z-index: 9999;
    }

    .context-word {
      cursor: pointer;
      padding: 2px 4px;
      border-radius: 4px;
      transition: all 0.2s ease;
      display: inline-block;
      user-select: text;
    }
    .context-word:hover {
      background: var(--progress-bg);
      color: var(--primary-color);
    }
    .current-word {
      font-weight: 600;
      color: var(--primary-color);
      background: var(--progress-bg);
      padding: 2px 4px;
      border-radius: 4px;
      scroll-margin-top: 100px;
    }

    .context-view.visible ~ .progress-bar,
    .context-view.visible ~ .progress-info,
    .context-view.visible ~ .speed-control,
    .context-view.visible ~ .wpm-indicator {
      display: none;
    }

    /* CHAPTERS & UNDO */
    .chapters-dropdown {
      position: relative;
      margin-right: auto;
      margin-left: 16px;
    }
    .chapters-button {
      padding: 8px 12px;
      background: var(--surface-color);
      border: 1px solid var(--progress-bg);
      border-radius: 8px;
      color: var(--text-color);
      font-size: 14px;
      font-weight: 500;
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    .chapters-button:active {
      background: var(--button-hover);
      transform: scale(0.98);
    }
    .chapters-list {
      position: absolute;
      top: 100%;
      left: 0;
      width: 280px;
      max-height: 60vh;
      background: var(--surface-color);
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      overflow-y: auto;
      opacity: 0;
      pointer-events: none;
      transform: translateY(8px);
      transition: all 0.2s ease;
      z-index: 1003;
      margin-top: 8px;
      padding: 8px;
    }
    .chapters-list.visible {
      opacity: 1;
      pointer-events: auto;
      transform: translateY(0);
    }
    .chapter-item {
      padding: 12px;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
      color: var(--text-color);
      font-size: 14px;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    .chapter-item:hover {
      background: var(--progress-bg);
    }
    .chapter-item.current {
      background: var(--progress-bg);
      color: var(--primary-color);
      font-weight: 500;
    }
    .chapter-progress {
      font-size: 12px;
      color: var(--primary-color);
      font-weight: 500;
    }

    .context-undo {
      padding: 8px 12px;
      background: var(--surface-color);
      border: 1px solid var(--progress-bg);
      border-radius: 8px;
      color: var(--text-color);
      font-size: 14px;
      font-weight: 500;
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    .context-undo:active {
      background: var(--button-hover);
      transform: scale(0.98);
    }

    .chapter-indicator {
      display: block;
      text-align: center;
      padding: 20px 0;
      margin: 20px 0;
      border-top: 1px solid var(--progress-bg);
      border-bottom: 1px solid var(--progress-bg);
      color: var(--primary-color);
      font-weight: 500;
      background: var(--surface-color);
      position: sticky;
      top: 60px;
      z-index: 1001;
    }

    /* -----------------------------------------------------------
       WPM INDICATOR
       ----------------------------------------------------------- */
    .wpm-indicator {
      position: fixed;
      right: 16px;
      top: 80px;
      background: var(--surface-color);
      color: var(--text-color);
      padding: 8px 16px;
      border-radius: 8px;
      font-size: 16px;
      font-weight: 500;
      opacity: 0;
      transform: translateY(-10px);
      transition: opacity 0.3s, transform 0.3s;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      z-index: 100;
    }
    .wpm-indicator.visible {
      opacity: 1;
      transform: translateY(0);
    }

    /* -----------------------------------------------------------
       PROGRESS NAV (RIGHT SLIDER)
       ----------------------------------------------------------- */
    .progress-nav {
      position: fixed;
      right: 24px;
      top: 120px;
      bottom: 80px;
      width: 12px;
      background: var(--progress-bg);
      border-radius: 6px;
      opacity: 1; /* always visible by default */
      cursor: pointer;
      z-index: 90;
    }
    .progress-nav-fill {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      background: var(--progress-fill);
      border-radius: 4px;
      transition: height 0.1s;
    }
    .progress-nav-tooltip {
      position: absolute;
      right: 24px;
      background: var(--surface-color);
      padding: 8px 12px;
      border-radius: 8px;
      font-size: 14px;
      white-space: nowrap;
      transform: translateY(-50%);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      opacity: 1;
      pointer-events: none;
      transition: opacity 0.2s;
    }
    .progress-nav-tooltip .word-preview {
      font-weight: 500;
      color: var(--primary-color);
    }

    /* Hide theme toggle in context view */
    .context-view.visible ~ .theme-toggle {
      display: none;
    }

    /* RESPONSIVE ADJUSTMENTS */
    @media (max-width: 640px) {
      .theme-toggle {
        flex-direction: column;
        align-items: flex-end;
        gap: 8px;
      }
      .wpm-controls {
        margin-left: 0;
        margin-top: 8px;
        width: calc(100% - 24px);
        justify-content: space-between;
        padding: 12px;
      }
      .wpm-controls button {
        width: 48px;
        height: 48px;
      }
      .wpm-controls button svg {
        width: 24px;
        height: 24px;
      }
    }
  </style>
</head>
<body>
  <div class="reader-container">

    <!-- BACK BUTTON -->
    <button class="back-button" onclick="window.location.href='/'">‚Üê Back</button>

    <!-- THEME & WPM CONTROLS (TOP RIGHT) -->
    <div class="theme-toggle">
      <div class="theme-buttons">
        <button class="theme-button active" data-theme="light">Light</button>
        <button class="theme-button" data-theme="dark">Dark</button>
        <button class="theme-button" data-theme="sand">Sand</button>
      </div>
      <div class="wpm-controls">
        <button onclick="updateWPM(state.currentWPM - 25)" title="Decrease WPM">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" d="M19 14l-7 7-7-7"/>
          </svg>
        </button>
        <div class="wpm-value">
          <span id="wpmValueTop">300</span> WPM
        </div>
        <button onclick="updateWPM(state.currentWPM + 25)" title="Increase WPM">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" d="M5 10l7-7 7 7"/>
          </svg>
        </button>
      </div>
      <button class="context-mode-button" id="contextModeButton" onclick="toggleContextView()">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16" />
        </svg>
        <span>Context View</span>
      </button>
    </div>

    <!-- PROGRESS BAR (LEFT) -->
    <div class="progress-bar" id="progressBar">
      <div class="progress-fill" id="progressFill"></div>
    </div>
    <div class="progress-info" id="progressInfo">
      <div>Chapter <span id="chapterNumber">1</span></div>
      <div>Page <span id="pageNumber">1</span></div>
      <div><span id="progressPercent">0</span>%</div>
    </div>

    <!-- SINGLE WORD DISPLAY -->
    <div class="word-boundary" id="wordBoundary">
      <div class="word-display" id="wordDisplay">
        Tap to start reading
      </div>
    </div>

    <!-- CONTEXT VIEW OVERLAY -->
    <div class="context-view" id="contextView">
      <div class="context-header">
        <div class="chapters-dropdown">
          <button class="chapters-button" onclick="toggleChaptersList()">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                    d="M4 6h16M4 12h16M4 18h16"/>
            </svg>
            Chapters
          </button>
          <div class="chapters-list" id="chaptersList"></div>
        </div>

        <button class="context-undo" onclick="undoLastPosition()" style="margin-right: 16px;">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                  d="M3 10h10a8 8 0 018 8v2M3 10l6 6M3 10l6-6"/>
          </svg>
          Undo
        </button>

        <button class="context-close-button" onclick="hideContextView()">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                  d="M6 18L18 6M6 6l12 12"/>
          </svg>
          Close
        </button>
      </div>
      <div class="context-content" id="contextContent">
        <!-- entire book text inserted here -->
      </div>
    </div>

    <!-- WPM INDICATOR -->
    <div class="wpm-indicator" id="wpmIndicator">
      <span id="wpmIndicatorValue">300</span> WPM
    </div>

    <!-- PROGRESS NAV (RIGHT) -->
    <div class="progress-nav" id="progressNav">
      <div class="progress-nav-fill" id="progressNavFill"></div>
      <div class="progress-nav-tooltip" id="progressNavTooltip">
        <div>Word <span id="wordNumber">0</span> / <span id="totalWords">0</span></div>
        <div class="word-preview" id="wordPreview"></div>
      </div>
    </div>
  </div>

  <script>
    /* ----------------------------------------------------------
       GLOBAL STATE
       ---------------------------------------------------------- */
    let state = {
      isPlaying: false,
      currentIndex: 0,
      words: [],
      chapters: [],
      undoStack: [],

      // user settings
      currentWPM: parseInt(localStorage.getItem('reader-wpm')) || 300,
      readingInterval: null,
      minWPM: 25,
      maxWPM: 1500,

      // context view
      contextViewActive: false,
      wasPlayingBeforeContext: false,

      // throttle saving
      saveTimeout: null
    };

    /* ----------------------------------------------------------
       INITIALIZE ON DOM READY
       ---------------------------------------------------------- */
    document.addEventListener('DOMContentLoaded', () => {
      initialize();

      // Save progress if user leaves
      document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
          saveProgress(true); // immediate
        }
      });
      window.addEventListener('beforeunload', () => {
        saveProgress(true);
      });
    });

    async function initialize() {
      try {
        const resp = await fetch(`/api/book/{{ book.id }}/content`);
        if (!resp.ok) throw new Error('Failed to fetch book content');

        const data = await resp.json();
        // parse words
        state.words = data.content.split(/\s+/).filter(w => w.length > 0);
        // set initial position
        if (data.current_position && !isNaN(data.current_position)) {
          let pos = parseInt(data.current_position, 10);
          if (pos >= 0 && pos < state.words.length) {
            state.currentIndex = pos;
          }
        }
        // chapters
        if (data.chapters) {
          state.chapters = data.chapters;
        }

        updateAllUI();
        setupEventListeners();
        setupProgressNav();
      } catch (err) {
        console.error('Error loading content:', err);
      }
    }

    /* ----------------------------------------------------------
       UPDATE UI
       ---------------------------------------------------------- */
    function updateAllUI() {
      // show current word in the center
      const display = document.getElementById('wordDisplay');
      display.textContent = state.words[state.currentIndex] || '';

      // update progress bar & nav
      updateProgress();
      updateProgressNav();

      // update top WPM
      document.getElementById('wpmValueTop').textContent = state.currentWPM;

      // possibly show chapter # if desired
      const c = findChapterForIndex(state.currentIndex);
      if (c) {
        document.getElementById('chapterNumber').textContent = c.title;
      }

      // throttle the saving (less frequent)
      saveProgress(false);
    }

    /* ----------------------------------------------------------
       EVENT LISTENERS
       ---------------------------------------------------------- */
    function setupEventListeners() {
      // main word boundary => tap to play/pause
      const wb = document.getElementById('wordBoundary');
      wb.addEventListener('click', () => {
        if (!state.contextViewActive) {
          toggleReading();
        }
      });

      // keyboard (space -> toggle, arrow up/down -> WPM)
      document.addEventListener('keydown', (e) => {
        if (e.code === 'Space') {
          e.preventDefault();
          toggleReading();
        } else if (e.code === 'ArrowUp') {
          e.preventDefault();
          updateWPM(state.currentWPM + 25);
        } else if (e.code === 'ArrowDown') {
          e.preventDefault();
          updateWPM(state.currentWPM - 25);
        }
      });

      // theme buttons
      document.querySelectorAll('.theme-button').forEach(btn => {
        btn.addEventListener('click', () => {
          setTheme(btn.dataset.theme);
        });
      });

      // initialize saved theme
      const savedTheme = localStorage.getItem('reader-theme') || 'light';
      setTheme(savedTheme);

      // context content => single delegated click for words
      document.getElementById('contextContent').addEventListener('click', (e) => {
        if (e.target.classList.contains('context-word') || e.target.classList.contains('current-word')) {
          const i = parseInt(e.target.dataset.index, 10);
          if (!isNaN(i)) {
            pushToUndoStack(state.currentIndex);
            state.currentIndex = i;
            updateAllUI();
            generateContextHTML();
            scrollCurrentWordIntoView();
            showPositionIndicator();
          }
        }
      });
    }

    /* ----------------------------------------------------------
       READING CONTROL
       ---------------------------------------------------------- */
    function toggleReading() {
      if (state.isPlaying) {
        pauseReading();
        document.getElementById('progressNavTooltip').style.opacity = '1';
      } else {
        startReading();
        document.getElementById('progressNavTooltip').style.opacity = '0';
      }
    }

    function startReading() {
      pauseReading(); // ensure no duplicates
      state.isPlaying = true;

      const intervalMS = calculateInterval(state.currentWPM);
      const disp = document.getElementById('wordDisplay');
      disp.textContent = state.words[state.currentIndex] || '';

      state.readingInterval = setInterval(() => {
        if (state.currentIndex >= state.words.length - 1) {
          pauseReading();
          return;
        }
        state.currentIndex++;
        disp.textContent = state.words[state.currentIndex];
        updateProgress();
        updateProgressNav();
        saveProgress(false);
      }, intervalMS);
    }

    function pauseReading() {
      state.isPlaying = false;
      if (state.readingInterval) {
        clearInterval(state.readingInterval);
        state.readingInterval = null;
      }
    }

    function calculateInterval(wpm) {
      return 60000 / wpm; // ms per word
    }

    /* ----------------------------------------------------------
       PROGRESS
       ---------------------------------------------------------- */
    function updateProgress() {
      let ratio = 0;
      if (state.words.length > 0) {
        ratio = state.currentIndex / (state.words.length - 1);
      }
      const pct = Math.round(ratio * 100);
      document.getElementById('progressFill').style.height = pct + '%';
      document.getElementById('progressPercent').textContent = pct;
    }

    /* ----------------------------------------------------------
       SAVE PROGRESS (THROTTLED)
       ---------------------------------------------------------- */
    function saveProgress(immediate = false) {
      // immediate => do it right now (on unload, etc.)
      // otherwise, wait a bit to avoid spamming the server
      if (immediate) {
        doSaveProgress();
        return;
      }
      if (state.saveTimeout) clearTimeout(state.saveTimeout);
      state.saveTimeout = setTimeout(() => {
        doSaveProgress();
      }, 2000);
    }

    async function doSaveProgress() {
      // local fallback
      localStorage.setItem('reader-wpm', state.currentWPM);
      localStorage.setItem(`book-{{ book.id }}-position`, state.currentIndex);

      try {
        await fetch(`/api/book/{{ book.id }}/position`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            position: state.currentIndex,
            wpm: state.currentWPM
          })
        });
      } catch (err) {
        console.warn('Could not save progress to server:', err);
      }
    }

    /* ----------------------------------------------------------
       WPM CONTROL
       ---------------------------------------------------------- */
    let wpmIndicatorTimer;
    function updateWPM(newVal) {
      let w = Math.max(state.minWPM, Math.min(state.maxWPM, newVal));
      state.currentWPM = w;
      document.getElementById('wpmValueTop').textContent = w;
      document.getElementById('wpmIndicatorValue').textContent = w;
      showWPMIndicator();

      if (state.isPlaying) {
        pauseReading();
        startReading();
      }
    }

    function showWPMIndicator() {
      const indicator = document.getElementById('wpmIndicator');
      indicator.classList.add('visible');
      if (wpmIndicatorTimer) clearTimeout(wpmIndicatorTimer);
      wpmIndicatorTimer = setTimeout(() => {
        indicator.classList.remove('visible');
      }, 1500);
    }

    /* ----------------------------------------------------------
       CONTEXT VIEW
       ---------------------------------------------------------- */
    function toggleContextView() {
      if (state.contextViewActive) {
        hideContextView();
      } else {
        showContextView();
      }
    }

    function showContextView() {
      state.wasPlayingBeforeContext = state.isPlaying;
      if (state.isPlaying) pauseReading();

      state.contextViewActive = true;
      document.body.style.overflow = 'hidden';
      generateContextHTML();

      const cv = document.getElementById('contextView');
      cv.classList.add('visible');

      // scroll current word into view
      requestAnimationFrame(() => {
        scrollCurrentWordIntoView(false);
      });

      // update button
      const btn = document.getElementById('contextModeButton');
      btn.classList.add('active');
      btn.innerHTML = `
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                d="M6 18L18 6M6 6l12 12"/>
        </svg>
        <span>Close View</span>
      `;
    }

    function hideContextView() {
      state.contextViewActive = false;
      document.body.style.overflow = '';

      const cv = document.getElementById('contextView');
      cv.classList.remove('visible');

      // if was playing, resume
      if (state.wasPlayingBeforeContext) {
        startReading();
      }
      state.wasPlayingBeforeContext = false;

      // update single word display
      document.getElementById('wordDisplay').textContent =
        state.words[state.currentIndex] || '';

      // update button
      const btn = document.getElementById('contextModeButton');
      btn.classList.remove('active');
      btn.innerHTML = `
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                d="M4 6h16M4 12h16M4 18h16"/>
        </svg>
        <span>Context View</span>
      `;
    }

    function generateContextHTML() {
      const container = document.getElementById('contextContent');
      container.innerHTML = '';

      let html = '';
      let chapterIndex = 0;
      let nextChapterPos = state.chapters.length > 0 ? state.chapters[0].position : -1;
      let chapterTitle = state.chapters.length > 0 ? state.chapters[0].title : null;

      // single loop to build text with chapter markers
      for (let i = 0; i < state.words.length; i++) {
        if (i === nextChapterPos) {
          // insert chapter indicator
          html += `<div class="chapter-indicator">${chapterTitle}</div>`;

          // move to next chapter
          chapterIndex++;
          if (chapterIndex < state.chapters.length) {
            nextChapterPos = state.chapters[chapterIndex].position;
            chapterTitle = state.chapters[chapterIndex].title;
          } else {
            nextChapterPos = -1;
          }
        }
        const cls = (i === state.currentIndex) ? 'current-word' : 'context-word';
        html += `<span class="${cls}" data-index="${i}">${state.words[i]}</span> `;
      }

      container.innerHTML = html;
    }

    function scrollCurrentWordIntoView(smooth = true) {
      const cw = document.querySelector('.current-word');
      if (cw) {
        cw.scrollIntoView({
          behavior: smooth ? 'smooth' : 'auto',
          block: 'center'
        });
      }
    }

    /* position indicator if you want a small ephemeral popup */
    function showPositionIndicator() {
      // If you have an element with id="positionIndicator", you can do:
      // const el = document.getElementById('positionIndicator');
      // if (el) {
      //   el.classList.add('visible');
      //   setTimeout(() => el.classList.remove('visible'), 2000);
      // }
      // For now, do nothing or implement a small toast.
    }

    /* ----------------------------------------------------------
       CHAPTERS
       ---------------------------------------------------------- */
    function toggleChaptersList() {
      const list = document.getElementById('chaptersList');
      list.classList.toggle('visible');
      if (list.classList.contains('visible')) {
        updateChaptersList();
      }
    }

    function updateChaptersList() {
      const list = document.getElementById('chaptersList');
      list.innerHTML = '';

      for (let i = 0; i < state.chapters.length; i++) {
        const chap = state.chapters[i];
        const nextPos = (i < state.chapters.length - 1)
          ? state.chapters[i + 1].position
          : state.words.length;

        // are we currently in this chapter?
        let inThisChapter = (state.currentIndex >= chap.position && state.currentIndex < nextPos);

        let progress = 0;
        if (inThisChapter) {
          let chapterSize = nextPos - chap.position;
          let offset = state.currentIndex - chap.position;
          progress = Math.round((offset / chapterSize) * 100);
        } else if (state.currentIndex >= nextPos) {
          // fully past
          progress = 100;
        }

        const div = document.createElement('div');
        div.className = 'chapter-item' + (inThisChapter ? ' current' : '');
        div.innerHTML = `
          <span>${chap.title}</span>
          <span class="chapter-progress">${progress}%</span>
        `;
        div.onclick = () => jumpToChapter(chap.position);
        list.appendChild(div);
      }
    }

    function jumpToChapter(pos) {
      pushToUndoStack(state.currentIndex);
      state.currentIndex = pos;
      updateAllUI();
      generateContextHTML();
      scrollCurrentWordIntoView();
      showPositionIndicator();
      document.getElementById('chaptersList').classList.remove('visible');
    }

    function findChapterForIndex(idx) {
      // do a quick loop or binary search. For simplicity:
      for (let i = 0; i < state.chapters.length; i++) {
        const chap = state.chapters[i];
        const nextPos = (i < state.chapters.length - 1) ? state.chapters[i + 1].position : state.words.length;
        if (idx >= chap.position && idx < nextPos) {
          return chap;
        }
      }
      return null;
    }

    /* ----------------------------------------------------------
       UNDO
       ---------------------------------------------------------- */
    function pushToUndoStack(pos) {
      state.undoStack.push(pos);
      if (state.undoStack.length > 10) {
        state.undoStack.shift();
      }
    }
    function undoLastPosition() {
      if (state.undoStack.length > 0) {
        const last = state.undoStack.pop();
        state.currentIndex = last;
        updateAllUI();
        if (state.contextViewActive) {
          generateContextHTML();
          scrollCurrentWordIntoView();
        }
      }
    }

    /* ----------------------------------------------------------
       THEME
       ---------------------------------------------------------- */
    function setTheme(theme) {
      document.documentElement.setAttribute('data-theme', theme);
      localStorage.setItem('reader-theme', theme);
      document.querySelectorAll('.theme-button').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.theme === theme);
      });
    }

    /* ----------------------------------------------------------
       PROGRESS NAV
       ---------------------------------------------------------- */
    function setupProgressNav() {
      const nav = document.getElementById('progressNav');
      const fill = document.getElementById('progressNavFill');
      const tooltip = document.getElementById('progressNavTooltip');
      const wordDisp = document.getElementById('wordDisplay');

      let isDragging = false;

      function updateFromY(clientY) {
        const rect = nav.getBoundingClientRect();
        let ratio = 1 - (clientY - rect.top) / rect.height;
        if (ratio < 0) ratio = 0;
        if (ratio > 1) ratio = 1;

        const i = Math.floor(ratio * (state.words.length - 1));
        const safe = Math.max(0, Math.min(i, state.words.length - 1));

        let pct = (safe / (state.words.length - 1)) * 100;
        fill.style.height = pct + '%';

        tooltip.innerHTML = `
          <div>Word ${safe + 1} / ${state.words.length} (${Math.round(pct)}%)</div>
          <div class="word-preview">${state.words[safe] || ''}</div>
        `;
        let tRect = tooltip.getBoundingClientRect();
        let tY = clientY - tRect.height / 2;
        let minY = rect.top;
        let maxY = rect.bottom - tRect.height;
        if (tY < minY) tY = minY;
        if (tY > maxY) tY = maxY;
        tooltip.style.top = tY + 'px';

        // immediate visual feedback
        wordDisp.textContent = state.words[safe];
        return safe;
      }

      function onDragStart(e) {
        isDragging = true;
        if (state.isPlaying) pauseReading();
        onDragMove(e);
      }
      function onDragMove(e) {
        if (!isDragging) return;
        e.preventDefault();
        const clientY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;
        state.currentIndex = updateFromY(clientY);
      }
      function onDragEnd() {
        if (!isDragging) return;
        isDragging = false;
        saveProgress(false);
      }

      // mouse
      nav.addEventListener('mousedown', onDragStart);
      document.addEventListener('mousemove', onDragMove);
      document.addEventListener('mouseup', onDragEnd);

      // touch
      nav.addEventListener('touchstart', onDragStart, { passive: false });
      document.addEventListener('touchmove', onDragMove, { passive: false });
      document.addEventListener('touchend', onDragEnd);
      document.addEventListener('touchcancel', onDragEnd);

      // press "N" to toggle
      document.addEventListener('keydown', (e) => {
        if (e.key.toLowerCase() === 'n') {
          let op = getComputedStyle(nav).opacity;
          nav.style.opacity = (op === '1') ? '0' : '1';
        }
      });

      // show tooltip by default since reading is initially paused
      tooltip.style.opacity = '1';
    }

    function updateProgressNav() {
      let ratio = 0;
      if (state.words.length > 1) {
        ratio = state.currentIndex / (state.words.length - 1);
      }
      let pct = ratio * 100;
      document.getElementById('progressNavFill').style.height = pct + '%';
      document.getElementById('wordNumber').textContent = state.currentIndex;
      document.getElementById('totalWords').textContent = state.words.length;
      document.getElementById('wordPreview').textContent = state.words[state.currentIndex] || '';
    }
  </script>
</body>
</html>
