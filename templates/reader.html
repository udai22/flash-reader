<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>{{ book.title }} - Virtual-Scroll Reader</title>

  <style>
    /* ====================== THEME VARIABLES ======================= */
    html[data-theme="light"] {
      --primary-color: #2563eb;
      --text-color: #1f2937;
      --bg-color: #f3f4f6;
      --surface-color: #ffffff;
      --progress-bg: rgba(37, 99, 235, 0.1);
      --progress-fill: rgba(37, 99, 235, 0.9);
      --button-bg: rgba(255, 255, 255, 0.9);
      --button-hover: #ffffff;
    }
    html[data-theme="dark"] {
      --primary-color: #60a5fa;
      --text-color: #e5e7eb;
      --bg-color: #111827;
      --surface-color: #1f2937;
      --progress-bg: rgba(96, 165, 250, 0.1);
      --progress-fill: rgba(96, 165, 250, 0.9);
      --button-bg: rgba(31, 41, 55, 0.9);
      --button-hover: #374151;
    }
    html[data-theme="sand"] {
      --primary-color: #9c4221;
      --text-color: #442c1d;
      --bg-color: #faf0e6;
      --surface-color: #fff8f0;
      --progress-bg: rgba(156, 66, 33, 0.1);
      --progress-fill: rgba(156, 66, 33, 0.9);
      --button-bg: rgba(255, 248, 240, 0.9);
      --button-hover: #fff8f0;
    }

    /* ====================== GLOBAL RESET ======================= */
    body {
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: var(--bg-color);
      color: var(--text-color);
      height: 100vh;
      width: 100vw;
      overflow: hidden;
      transition: background-color 0.3s, color 0.3s;
      padding-bottom: 90px; /* extra space for bottom controls */
    }
    .reader-container {
      position: relative;
      width: 100%;
      height: 100%;
    }

    /* ====================== BACK BUTTON ======================= */
    .back-button {
      position: fixed;
      left: 16px;
      top: 16px;
      padding: 8px 16px;
      background: var(--button-bg);
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-size: 14px;
      z-index: 100;
    }

    /* ====================== SINGLE WORD DISPLAY ====================== */
    .word-boundary {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      border-radius: 12px;
      background: var(--bg-color);
      padding: 40px;
      text-align: center;
      cursor: pointer;
      user-select: none;
    }
    .word-display {
      font-size: 36px;
      font-weight: 500;
    }

    /* ===================== BOTTOM CONTROLS BAR ===================== */
    .bottom-bar {
      position: fixed;
      left: 0;
      right: 0;
      bottom: 0;
      height: 90px;
      background: var(--surface-color);
      box-shadow: 0 -2px 8px rgba(0,0,0,0.1);
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 24px;
      padding: 0 16px;
      z-index: 10002;
    }
    .control-group {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    /* Use existing button styles for controls */
    .control-group button {
      padding: 8px 12px;
      background: var(--button-bg);
      color: var(--text-color);
      border: 1px solid var(--progress-bg);
      border-radius: 8px;
      cursor: pointer;
      font-size: 14px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    /* WPM value display */
    .wpm-value {
      font-size: 16px;
      font-weight: 600;
      min-width: 70px;
      text-align: center;
    }
    /* Theme dropdown styling matching original buttons */
    .theme-dropdown {
      position: relative;
      display: inline-block;
    }
    .theme-dropdown-button {
      padding: 8px 12px;
      background: var(--button-bg);
      color: var(--text-color);
      border: 1px solid var(--progress-bg);
      border-radius: 8px;
      cursor: pointer;
      font-size: 14px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    .theme-dropdown-menu {
      position: absolute;
      bottom: 110%;
      left: 50%;
      transform: translateX(-50%);
      background: var(--surface-color);
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      border-radius: 8px;
      overflow: hidden;
      display: none;
      flex-direction: column;
      min-width: 100px;
      z-index: 10003;
    }
    .theme-dropdown-menu.active {
      display: flex;
    }
    .theme-dropdown-menu button {
      padding: 8px 12px;
      background: var(--button-bg);
      border: none;
      text-align: left;
      cursor: pointer;
      font-size: 14px;
    }
    .theme-dropdown-menu button.active {
      background: var(--primary-color);
      color: #fff;
    }
    .theme-dropdown-menu button:hover:not(.active) {
      background: var(--button-hover);
    }

    /* ====================== CONTEXT VIEW TOGGLE BUTTON ====================== */
    .context-mode-button {
      padding: 8px 12px;
      background: var(--button-bg);
      color: var(--text-color);
      border: 1px solid var(--progress-bg);
      border-radius: 8px;
      font-size: 14px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 6px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    .context-mode-button.active {
      background: var(--primary-color);
      color: #fff;
      border-color: var(--primary-color);
    }

    /* ====================== WPM INDICATOR ====================== */
    .wpm-indicator {
      position: fixed;
      right: 16px;
      top: 80px;
      background: var(--surface-color);
      padding: 8px 16px;
      border-radius: 8px;
      font-size: 16px;
      font-weight: 500;
      opacity: 0;
      transform: translateY(-10px);
      transition: opacity 0.3s, transform 0.3s;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      z-index: 100;
    }
    .wpm-indicator.visible {
      opacity: 1;
      transform: translateY(0);
    }

    /* ====================== CONTEXT VIEW OVERLAY ====================== */
    .context-view {
      display: none;
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: var(--surface-color);
      z-index: 9999;
      opacity: 0;
      transition: opacity 0.3s ease-out;
    }
    .context-view.visible {
      display: block;
      opacity: 1;
    }
    .context-header {
      position: sticky;
      top: 0;
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: var(--surface-color);
      border-bottom: 1px solid var(--progress-bg);
      padding: 0 16px;
      height: 60px;
      z-index: 10000;
    }
    .chapters-dropdown {
      position: relative;
      margin-left: 16px;
    }
    .chapters-button,
    .context-undo,
    .context-close-button {
      padding: 8px 12px;
      background: var(--button-bg);
      color: var(--text-color);
      border: 1px solid var(--progress-bg);
      border-radius: 8px;
      font-size: 14px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 6px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    .chapters-list {
      position: absolute;
      top: 100%;
      left: 0;
      width: 240px;
      max-height: 60vh;
      background: var(--surface-color);
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
      border-radius: 8px;
      overflow-y: auto;
      opacity: 0;
      pointer-events: none;
      transform: translateY(8px);
      transition: all 0.2s;
      margin-top: 8px;
      z-index: 1003;
    }
    .chapters-list.visible {
      opacity: 1;
      pointer-events: auto;
      transform: translateY(0);
    }
    .chapter-item {
      padding: 12px;
      border-radius: 6px;
      cursor: pointer;
      transition: background 0.2s;
    }
    .chapter-item:hover {
      background: var(--progress-bg);
    }
    .chapter-item.current {
      background: var(--progress-bg);
      color: var(--primary-color);
      font-weight: 500;
    }

    /* ===================== CLUSTERIZE / CONTEXT VIEW ===================== */
    .context-content-wrapper {
      width: 100%;
      height: calc(100vh - 60px);
      overflow: auto;
      -webkit-overflow-scrolling: touch;
      box-sizing: border-box;
      margin: 0 auto;
      padding: 20px;
      line-height: 1.8;
      font-size: 18px;
      max-width: 900px;
    }
    .clusterize-no-data {
      padding: 12px;
      opacity: 0.6;
      font-style: italic;
    }
    .clusterize table {
      width: 100%;
      border-collapse: collapse;
    }
    .clusterize td {
      padding: 8px 0;
      line-height: 1.8;
    }
    #contextScrollArea {
      scroll-behavior: smooth;
    }

    /* ===================== WORD SPANS ===================== */
    .virtual-word {
      cursor: pointer;
      padding: 4px 6px;
      margin: 0 1px;
      border-radius: 4px;
      display: inline-block;
      user-select: text;
      transition: background 0.2s, color 0.2s;
    }
    .virtual-word:hover {
      background: var(--progress-bg);
      color: var(--primary-color);
    }
    .current-word {
      background: var(--primary-color) !important;
      color: #fff !important;
      font-weight: 600;
      padding: 4px 6px;
      margin: 0 1px;
      border-radius: 4px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
    }
    .chapter-indicator {
      display: block;
      text-align: center;
      padding: 24px 0;
      margin: 32px 0;
      border-top: 1px solid var(--progress-bg);
      border-bottom: 1px solid var(--progress-bg);
      color: var(--primary-color);
      font-weight: 600;
      font-size: 20px;
      background: var(--surface-color);
      letter-spacing: 0.5px;
    }

    /* ===================== PROGRESS NAV (RIGHT) ===================== */
    .progress-nav {
      position: fixed;
      right: 24px;
      top: 120px;
      bottom: 80px;
      width: 12px;
      background: var(--progress-bg);
      border-radius: 6px;
      cursor: pointer;
      z-index: 90;
    }
    .progress-nav-fill {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      background: var(--progress-fill);
      border-radius: 4px;
      transition: height 0.1s;
    }
    .progress-nav-tooltip {
      position: absolute;
      right: 24px;
      background: var(--surface-color);
      padding: 8px 12px;
      border-radius: 8px;
      font-size: 14px;
      white-space: nowrap;
      transform: translateY(-50%);
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      pointer-events: none;
      transition: opacity 0.2s;
      opacity: 1;
    }
    .word-preview {
      color: var(--primary-color);
      font-weight: 500;
    }

    /* ===================== PULSE ANIMATION ===================== */
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.1); }
      100% { transform: scale(1); }
    }
  </style>
</head>
<body>
<div class="reader-container">
  <!-- ============== BACK BUTTON ============== -->
  <button class="back-button" onclick="window.location.href='/'">← Back</button>

  <!-- ============== SINGLE WORD DISPLAY ============== -->
  <div class="word-boundary" id="wordBoundary">
    <div class="word-display" id="wordDisplay">Tap to start reading</div>
  </div>

  <!-- ============== WPM INDICATOR ====================== -->
  <div class="wpm-indicator" id="wpmIndicator">
    <span id="wpmIndicatorValue">300</span> WPM
  </div>

  <!-- ============== CONTEXT VIEW (OVERLAY) ====================== -->
  <div class="context-view" id="contextView">
    <div class="context-header">
      <div class="chapters-dropdown">
        <button class="chapters-button" onclick="toggleChaptersList()">Chapters</button>
        <div class="chapters-list" id="chaptersList"></div>
      </div>
      <button class="context-undo" onclick="undoLastPosition()">Undo</button>
      <button class="context-close-button" onclick="hideContextView()">Close</button>
    </div>
    <div class="context-content-wrapper" id="contextScrollArea">
      <table class="clusterize" style="border-collapse:collapse;width:100%;">
        <tbody id="chunksContainer" class="clusterize-content"></tbody>
      </table>
      <div class="clusterize-no-data">Loading…</div>
    </div>
  </div>

  <!-- ============== PROGRESS NAV (RIGHT) ====================== -->
  <div class="progress-nav" id="progressNav">
    <div class="progress-nav-fill" id="progressNavFill"></div>
    <div class="progress-nav-tooltip" id="progressNavTooltip">
      <div>Word <span id="wordNumber">0</span> / <span id="totalWords">0</span></div>
      <div class="word-preview" id="wordPreview"></div>
    </div>
  </div>

  <!-- ============== BOTTOM CONTROLS BAR ====================== -->
  <div class="bottom-bar">
    <!-- WPM and Skip controls -->
    <div class="control-group">
      <button onclick="jumpWords(-50)">-50</button>
      <button onclick="updateWPM(state.currentWPM - 25)">-25</button>
      <div class="wpm-value"><span id="wpmValueTop">300</span> WPM</div>
      <button onclick="updateWPM(state.currentWPM + 25)">+25</button>
      <button onclick="jumpWords(50)">+50</button>
    </div>
    <!-- Context view toggle -->
    <div class="control-group">
      <button class="context-mode-button" id="contextModeButton" onclick="toggleContextView()">
        <svg width="16" height="16" viewBox="0 0 24 24" stroke="currentColor" fill="none">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                d="M4 6h16M4 12h16M4 18h16"/>
        </svg>
        <span>Context View</span>
      </button>
    </div>
    <!-- Theme dropdown -->
    <div class="control-group">
      <div class="theme-dropdown">
        <button class="theme-dropdown-button" onclick="toggleThemeMenu()">Theme</button>
        <div class="theme-dropdown-menu" id="themeMenu">
          <button data-theme="light" onclick="setTheme(this.dataset.theme); toggleThemeMenu();" class="theme-option">Light</button>
          <button data-theme="dark" onclick="setTheme(this.dataset.theme); toggleThemeMenu();" class="theme-option">Dark</button>
          <button data-theme="sand" onclick="setTheme(this.dataset.theme); toggleThemeMenu();" class="theme-option">Sand</button>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
'use strict';

/* ========================================================================
   GLOBAL STATE
========================================================================= */
const state = {
  isPlaying: false,
  currentIndex: 0,
  words: [],
  chapters: [],
  undoStack: [],
  currentWPM: parseInt(localStorage.getItem('reader-wpm'), 10) || 300,
  readingInterval: null,
  minWPM: 100,
  maxWPM: 1200,
  contextViewActive: false,
  wasPlayingBeforeContext: false,
  clusterize: null,
  allRows: [],
  wordsPerRow: 10,
  saveTimeout: null,
};

/* ========================================================================
   MAIN SETUP
========================================================================= */
document.addEventListener('DOMContentLoaded', async () => {
  try {
    if (document.fonts && document.fonts.ready) {
      await document.fonts.ready.catch(() => {});
    }
    const resp = await fetch(`/api/book/{{ book.id }}/content`);
    if (!resp.ok) {
      throw new Error('Failed to fetch book content');
    }
    const data = await resp.json();
    const rawContent = data.content || '';
    const tokens = rawContent.match(/\w+|\S/g) || [];
    state.words = tokens;
    const pos = parseInt(data.current_position, 10) || 0;
    state.currentIndex = Math.min(Math.max(pos, 0), state.words.length - 1);
    state.chapters = data.chapters || [];
    buildAllRows();
    updateAllUI();
    setupEventListeners();
    setupProgressNav();
    let clusterizeInitialized = false;
    state.clusterize = new Clusterize({
      scrollId: 'contextScrollArea',
      contentId: 'chunksContainer',
      rows: state.allRows,
      no_data_text: 'No data',
      rows_in_block: 50,
      blocks_in_cluster: 4,
      callbacks: {
        clusterWillChange: function() {
          if (clusterizeInitialized) {
            const container = document.getElementById('contextScrollArea');
            if (container && state.clusterize) {
              state.clusterize.options.scroll_top = container.scrollTop;
            }
          }
        },
        clusterChanged: function() {
          if (state.contextViewActive) {
            attachWordClickHandlers();
            if (!state.initialScrollDone) {
              scrollCurrentWordIntoView(false);
            }
          }
        }
      }
    });
    clusterizeInitialized = true;
  } catch (err) {
    console.error('Error during initialization:', err);
  }
});

/* ========================================================================
   BUILDING ROWS FOR CLUSTERIZE
========================================================================= */
function buildAllRows() {
  state.allRows = [];
  let chapterIndex = 0;
  let nextChapterPos = (state.chapters.length) ? state.chapters[0].position : -1;
  let chapterTitle = (state.chapters.length) ? state.chapters[0].title : null;
  state.wordsPerRow = 22;
  let rowWords = [];
  let currentWordFound = false;
  for (let i = 0; i < state.words.length; i++) {
    if (chapterIndex < state.chapters.length && i === nextChapterPos) {
      if (rowWords.length > 0) {
        const rowHTML = rowWords.map(({ word, index }) => {
          const isCurrentWord = index === state.currentIndex;
          if (isCurrentWord) currentWordFound = true;
          const cls = isCurrentWord ? 'current-word' : 'virtual-word';
          return `<span class="${cls}" data-index="${index}">${word}</span>`;
        }).join(' ');
        state.allRows.push(`<tr><td>${rowHTML}</td></tr>`);
        rowWords = [];
      }
      state.allRows.push(`
        <tr><td>
          <div class="chapter-indicator">${chapterTitle}</div>
        </td></tr>
      `);
      chapterIndex++;
      if (chapterIndex < state.chapters.length) {
        nextChapterPos = state.chapters[chapterIndex].position;
        chapterTitle = state.chapters[chapterIndex].title;
      } else {
        nextChapterPos = -1;
      }
    }
    rowWords.push({ word: state.words[i], index: i });
    if (rowWords.length >= state.wordsPerRow || i === state.words.length - 1) {
      const rowHTML = rowWords.map(({ word, index }) => {
        const isCurrentWord = index === state.currentIndex;
        if (isCurrentWord) currentWordFound = true;
        const cls = isCurrentWord ? 'current-word' : 'virtual-word';
        return `<span class="${cls}" data-index="${index}">${word}</span>`;
      }).join(' ');
      state.allRows.push(`<tr><td>${rowHTML}</td></tr>`);
      rowWords = [];
    }
  }
  return currentWordFound;
}
function rebuildRowsAndRefreshCluster() {
  buildAllRows();
  if (state.clusterize) {
    state.clusterize.update(state.allRows);
  }
  attachWordClickHandlers();
}

/* ========================================================================
   CLICK EVENTS ON WORDS (in Context View)
========================================================================= */
function attachWordClickHandlers() {
  const container = document.getElementById('chunksContainer');
  if (!container) return;
  const oldWords = container.querySelectorAll('.virtual-word, .current-word');
  oldWords.forEach(el => {
    const clone = el.cloneNode(true);
    el.parentNode.replaceChild(clone, el);
  });
  const words = container.querySelectorAll('.virtual-word, .current-word');
  words.forEach(el => {
    el.addEventListener('click', (e) => {
      e.preventDefault();
      const newIndex = parseInt(e.target.dataset.index, 10);
      if (!isNaN(newIndex) && newIndex !== state.currentIndex) {
        pushToUndoStack(state.currentIndex);
        state.currentIndex = newIndex;
        updateAllUI();
        buildAllRows();
        if (state.clusterize) {
          state.clusterize.update(state.allRows);
        }
        requestAnimationFrame(() => {
          scrollCurrentWordIntoView(true);
        });
      }
    });
  });
}

/* ========================================================================
   SCROLLING A PARTICULAR INDEX INTO VIEW
========================================================================= */
function scrollIndexIntoView(index) {
  const rowNum = Math.floor(index / state.wordsPerRow);
  const container = document.getElementById('contextScrollArea');
  if (container) {
    container.scrollTop = rowNum * 40;
  }
}

/* ========================================================================
   EVENT LISTENERS & UI
========================================================================= */
function setupEventListeners() {
  const wb = document.getElementById('wordBoundary');
  wb.addEventListener('click', () => {
    if (!state.contextViewActive) {
      toggleReading();
    }
  });
  document.addEventListener('keydown', (e) => {
    switch (e.code) {
      case 'Space':
        e.preventDefault();
        toggleReading();
        break;
      case 'ArrowUp':
        e.preventDefault();
        updateWPM(state.currentWPM + 25);
        break;
      case 'ArrowDown':
        e.preventDefault();
        updateWPM(state.currentWPM - 25);
        break;
      case 'ArrowLeft':
        e.preventDefault();
        jumpWords(-10);
        break;
      case 'ArrowRight':
        e.preventDefault();
        jumpWords(10);
        break;
      case 'PageUp':
        e.preventDefault();
        jumpWords(-100);
        break;
      case 'PageDown':
        e.preventDefault();
        jumpWords(100);
        break;
      default:
        break;
    }
  });
}
function updateAllUI() {
  const display = document.getElementById('wordDisplay');
  display.textContent = state.words[state.currentIndex] || '';
  updateProgressNav();
  document.getElementById('wpmValueTop').textContent = state.currentWPM.toString();
  saveProgress(false);
}

/* ========================================================================
   READING CONTROL
========================================================================= */
function toggleReading() {
  if (state.isPlaying) {
    pauseReading();
    document.getElementById('progressNavTooltip').style.opacity = '1';
  } else {
    startReading();
    document.getElementById('progressNavTooltip').style.opacity = '0';
  }
}
function startReading() {
  pauseReading();
  state.isPlaying = true;
  const intervalMS = 60000 / state.currentWPM;
  const disp = document.getElementById('wordDisplay');
  disp.textContent = state.words[state.currentIndex] || '';
  state.readingInterval = setInterval(() => {
    if (state.currentIndex >= state.words.length - 1) {
      pauseReading();
      return;
    }
    state.currentIndex++;
    disp.textContent = state.words[state.currentIndex] || '';
    updateProgressNav();
    saveProgress(false);
  }, intervalMS);
}
function pauseReading() {
  state.isPlaying = false;
  if (state.readingInterval) {
    clearInterval(state.readingInterval);
    state.readingInterval = null;
  }
}
function jumpWords(offset) {
  const oldIndex = state.currentIndex;
  let newIndex = oldIndex + offset;
  newIndex = Math.max(0, Math.min(newIndex, state.words.length - 1));
  pushToUndoStack(oldIndex);
  state.currentIndex = newIndex;
  updateAllUI();
  if (state.isPlaying) {
    pauseReading();
    startReading();
  }
  if (state.contextViewActive && state.clusterize) {
    rebuildRowsAndRefreshCluster();
    scrollIndexIntoView(newIndex);
  }
}

/* ========================================================================
   SAVE PROGRESS
========================================================================= */
function saveProgress(immediate) {
  if (immediate) {
    doSaveProgress();
    return;
  }
  if (state.saveTimeout) {
    clearTimeout(state.saveTimeout);
  }
  state.saveTimeout = setTimeout(() => {
    doSaveProgress();
  }, 1000);
}
async function doSaveProgress() {
  localStorage.setItem('reader-wpm', state.currentWPM);
  localStorage.setItem(`book-{{ book.id }}-position`, state.currentIndex);
  try {
    await fetch(`/api/book/{{ book.id }}/position`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ position: state.currentIndex, wpm: state.currentWPM })
    });
  } catch (err) {
    console.warn('Could not save progress:', err);
  }
}

/* ========================================================================
   WPM CONTROL
========================================================================= */
let wpmIndicatorTimer;
function updateWPM(val) {
  const w = Math.max(state.minWPM, Math.min(state.maxWPM, val));
  state.currentWPM = w;
  document.getElementById('wpmValueTop').textContent = String(w);
  document.getElementById('wpmIndicatorValue').textContent = String(w);
  showWPMIndicator();
  if (state.isPlaying) {
    pauseReading();
    startReading();
  }
}
function showWPMIndicator() {
  const ind = document.getElementById('wpmIndicator');
  ind.classList.add('visible');
  if (wpmIndicatorTimer) {
    clearTimeout(wpmIndicatorTimer);
  }
  wpmIndicatorTimer = setTimeout(() => {
    ind.classList.remove('visible');
  }, 1500);
}

/* ========================================================================
   CONTEXT VIEW TOGGLE
========================================================================= */
function toggleContextView() {
  if (state.contextViewActive) {
    hideContextView();
  } else {
    showContextView();
  }
}
function showContextView() {
  state.wasPlayingBeforeContext = state.isPlaying;
  if (state.isPlaying) {
    pauseReading();
  }
  state.contextViewActive = true;
  state.initialScrollDone = false;
  const cv = document.getElementById('contextView');
  const currentWordFound = buildAllRows();
  if (!currentWordFound) {
    state.currentIndex = Math.max(0, Math.min(state.currentIndex, state.words.length - 1));
    buildAllRows();
  }
  const currentChunkIndex = Math.floor(state.currentIndex / state.wordsPerRow);
  const container = document.getElementById('contextScrollArea');
  const chunkHeight = 40;
  const scrollOffset = currentChunkIndex * chunkHeight;
  if (state.clusterize) {
    state.clusterize.options.scroll_top = scrollOffset;
    state.clusterize.update(state.allRows);
  }
  cv.style.display = 'block';
  requestAnimationFrame(() => {
    cv.classList.add('visible');
    requestAnimationFrame(() => {
      if (container) {
        container.scrollTop = scrollOffset;
        setTimeout(() => {
          const currentEl = document.querySelector('.current-word');
          if (!currentEl) {
            scrollCurrentWordIntoView(false);
          } else {
            const containerRect = container.getBoundingClientRect();
            const elementRect = currentEl.getBoundingClientRect();
            const offset = elementRect.top - containerRect.top - (containerRect.height / 2) + (elementRect.height / 2);
            container.scrollBy({
              top: offset,
              behavior: 'auto'
            });
          }
          state.initialScrollDone = true;
        }, 50);
      }
    });
  });
  const btn = document.getElementById('contextModeButton');
  btn.classList.add('active');
  btn.innerHTML = `
    <svg width="16" height="16" viewBox="0 0 24 24" stroke="currentColor" fill="none">
      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
            d="M6 18L18 6M6 6l12 12"/>
    </svg>
    <span>Close View</span>
  `;
}
function hideContextView() {
  state.contextViewActive = false;
  const cv = document.getElementById('contextView');
  cv.classList.remove('visible');
  setTimeout(() => {
    if (!state.contextViewActive) {
      cv.style.display = 'none';
      if (state.wasPlayingBeforeContext) {
        startReading();
      }
    }
  }, 300);
  state.wasPlayingBeforeContext = false;
  const btn = document.getElementById('contextModeButton');
  btn.classList.remove('active');
  btn.innerHTML = `
    <svg width="16" height="16" viewBox="0 0 24 24" stroke="currentColor" fill="none">
      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
            d="M4 6h16M4 12h16M4 18h16"/>
    </svg>
    <span>Context View</span>
  `;
}

/* ========================================================================
   CHAPTERS & UNDO
========================================================================= */
function toggleChaptersList() {
  const list = document.getElementById('chaptersList');
  list.classList.toggle('visible');
  if (list.classList.contains('visible')) {
    updateChaptersList();
  }
}
function updateChaptersList() {
  const list = document.getElementById('chaptersList');
  list.innerHTML = '';
  for (let i = 0; i < state.chapters.length; i++) {
    const chap = state.chapters[i];
    const nextPos = (i < state.chapters.length - 1) ? state.chapters[i+1].position : state.words.length;
    const inThisChapter = (state.currentIndex >= chap.position && state.currentIndex < nextPos);
    let progress = 0;
    if (inThisChapter) {
      const chapterSize = nextPos - chap.position;
      const offset = state.currentIndex - chap.position;
      progress = Math.round((offset / chapterSize) * 100);
    } else if (state.currentIndex >= nextPos) {
      progress = 100;
    }
    const div = document.createElement('div');
    div.className = 'chapter-item' + (inThisChapter ? ' current' : '');
    div.innerHTML = `${chap.title} <span style="float:right;">${progress}%</span>`;
    div.onclick = () => {
      jumpToChapter(chap.position);
    };
    list.appendChild(div);
  }
}
function jumpToChapter(pos) {
  pushToUndoStack(state.currentIndex);
  state.currentIndex = pos;
  updateAllUI();
  rebuildRowsAndRefreshCluster();
  scrollIndexIntoView(pos);
  document.getElementById('chaptersList').classList.remove('visible');
}
function pushToUndoStack(pos) {
  state.undoStack.push(pos);
  if (state.undoStack.length > 20) {
    state.undoStack.shift();
  }
}
function undoLastPosition() {
  if (state.undoStack.length > 0) {
    const last = state.undoStack.pop();
    state.currentIndex = last;
    updateAllUI();
    if (state.contextViewActive && state.clusterize) {
      rebuildRowsAndRefreshCluster();
      scrollIndexIntoView(last);
    }
  }
}

/* ========================================================================
   THEME DROPDOWN
========================================================================= */
function setTheme(theme) {
  document.documentElement.setAttribute('data-theme', theme);
  localStorage.setItem('reader-theme', theme);
  const themeButtons = document.querySelectorAll('.theme-dropdown-menu button');
  themeButtons.forEach((btn) => {
    btn.classList.toggle('active', btn.dataset.theme === theme);
  });
}
function toggleThemeMenu() {
  const menu = document.getElementById('themeMenu');
  menu.classList.toggle('active');
}

/* ========================================================================
   PROGRESS NAV
========================================================================= */
function setupProgressNav() {
  const nav = document.getElementById('progressNav');
  const fill = document.getElementById('progressNavFill');
  const tooltip = document.getElementById('progressNavTooltip');
  const wordDisp = document.getElementById('wordDisplay');
  let isDragging = false;
  function updateFromY(clientY) {
    const rect = nav.getBoundingClientRect();
    let ratio = 1 - (clientY - rect.top) / rect.height;
    ratio = Math.max(0, Math.min(ratio, 1));
    let i = Math.floor(ratio * (state.words.length - 1));
    i = Math.max(0, Math.min(i, state.words.length - 1));
    const pct = Math.round((i / (state.words.length - 1)) * 100);
    fill.style.height = pct + '%';
    tooltip.innerHTML = `
      <div>Word ${i + 1} / ${state.words.length} (${pct}%)</div>
      <div class="word-preview">${state.words[i] || ''}</div>
    `;
    const tRect = tooltip.getBoundingClientRect();
    let tY = clientY - (tRect.height / 2);
    const minY = rect.top;
    const maxY = rect.bottom - tRect.height;
    if (tY < minY) tY = minY;
    if (tY > maxY) tY = maxY;
    tooltip.style.top = tY + 'px';
    wordDisp.textContent = state.words[i] || '';
    return i;
  }
  function onDragStart(e) {
    isDragging = true;
    if (state.isPlaying) { pauseReading(); }
    onDragMove(e);
  }
  function onDragMove(e) {
    if (!isDragging) return;
    e.preventDefault();
    const clientY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;
    state.currentIndex = updateFromY(clientY);
    updateProgressNav();
  }
  function onDragEnd() {
    if (!isDragging) return;
    isDragging = false;
    saveProgress(false);
    if (state.contextViewActive && state.clusterize) {
      rebuildRowsAndRefreshCluster();
      scrollIndexIntoView(state.currentIndex);
    }
  }
  nav.addEventListener('mousedown', onDragStart);
  document.addEventListener('mousemove', onDragMove);
  document.addEventListener('mouseup', onDragEnd);
  nav.addEventListener('touchstart', onDragStart, { passive: false });
  document.addEventListener('touchmove', onDragMove, { passive: false });
  document.addEventListener('touchend', onDragEnd);
  document.addEventListener('touchcancel', onDragEnd);
  document.addEventListener('keydown', (e) => {
    if (e.key.toLowerCase() === 'n') {
      const style = window.getComputedStyle(nav);
      const op = style.opacity;
      nav.style.opacity = (op === '1') ? '0' : '1';
    }
  });
  tooltip.style.opacity = '1';
}
function updateProgressNav() {
  if (state.words.length < 2) return;
  const fill = document.getElementById('progressNavFill');
  const wordNumber = document.getElementById('wordNumber');
  const totalWords = document.getElementById('totalWords');
  const wordPreview = document.getElementById('wordPreview');
  const ratio = state.currentIndex / (state.words.length - 1);
  const pct = ratio * 100;
  fill.style.height = pct + '%';
  wordNumber.textContent = (state.currentIndex + 1).toString();
  totalWords.textContent = state.words.length.toString();
  wordPreview.textContent = state.words[state.currentIndex] || '';
}
function scrollCurrentWordIntoView(smooth = true) {
  requestAnimationFrame(() => {
    const currentEl = document.querySelector('.current-word');
    const container = document.getElementById('contextScrollArea');
    if (!currentEl || !container) {
      buildAllRows();
      if (state.clusterize) {
        state.clusterize.update(state.allRows);
        setTimeout(() => {
          const rebuiltEl = document.querySelector('.current-word');
          if (rebuiltEl && container) {
            const containerRect = container.getBoundingClientRect();
            const elementRect = rebuiltEl.getBoundingClientRect();
            const offset = elementRect.top - containerRect.top - (containerRect.height / 2) + (elementRect.height / 2);
            container.scrollBy({
              top: offset,
              behavior: smooth ? 'smooth' : 'auto'
            });
            rebuiltEl.style.animation = 'none';
            rebuiltEl.offsetHeight;
            rebuiltEl.style.animation = 'pulse 2s ease-in-out';
          }
        }, 50);
      }
      return;
    }
    const containerRect = container.getBoundingClientRect();
    const elementRect = currentEl.getBoundingClientRect();
    const isInView = (elementRect.top >= containerRect.top && elementRect.bottom <= containerRect.bottom);
    if (!isInView) {
      const offset = elementRect.top - containerRect.top - (containerRect.height / 2) + (elementRect.height / 2);
      container.scrollBy({
        top: offset,
        behavior: smooth ? 'smooth' : 'auto'
      });
    }
    currentEl.style.animation = 'none';
    currentEl.offsetHeight;
    currentEl.style.animation = 'pulse 2s ease-in-out';
  });
}
// Simple helper for events
function on(evt, element, fnc) {
  return element.addEventListener ? element.addEventListener(evt, fnc, false) : element.attachEvent("on" + evt, fnc);
}
</script>

<!-- Inline Clusterize.js -->
<script>
/* Clusterize.js - v0.19.0 - 2020
   http://NeXTs.github.com/Clusterize.js/
   Copyright (c) 2015 Denis Lukov; Licensed MIT */
;(function(name, definition) {
    if (typeof module != 'undefined') module.exports = definition();
    else if (typeof define == 'function' && typeof define.amd == 'object') define(definition);
    else this[name] = definition();
}('Clusterize', function() {
  "use strict"
  var ie = (function(){
    var undef,rv = -1;
    var ua = window.navigator.userAgent;
    var msie = ua.indexOf('MSIE ');
    var trident = ua.indexOf('Trident/');
    if (msie > 0) {
      rv = parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);
    } else if (trident > 0) {
      var rvNum = ua.indexOf('rv:');
      rv = parseInt(ua.substring(rvNum + 3, ua.indexOf('.', rvNum)), 10);
    }
    return ((rv > -1) ? rv : undef);
  }());
  var is_mac = navigator.platform.toLowerCase().indexOf('mac') + 1;
  var Clusterize = function(data) {
    if( ! (this instanceof Clusterize))
      return new Clusterize(data);
    var self = this;
    var defaults = {
      rows_in_block: 50,
      blocks_in_cluster: 4,
      tag: null,
      show_no_data_row: true,
      no_data_class: 'clusterize-no-data',
      no_data_text: 'No data',
      keep_parity: true,
      callbacks: {}
    }
    self.options = {};
    var options = ['rows_in_block', 'blocks_in_cluster', 'show_no_data_row', 'no_data_class', 'no_data_text', 'keep_parity', 'tag', 'callbacks'];
    for(var i = 0, option; option = options[i]; i++) {
      self.options[option] = (typeof data[option] != 'undefined' && data[option] != null)
        ? data[option]
        : defaults[option];
    }
    var elems = ['scroll', 'content'];
    for(var i = 0, elem; elem = elems[i]; i++) {
      self[elem + '_elem'] = data[elem + 'Id']
        ? document.getElementById(data[elem + 'Id'])
        : data[elem + 'Elem'];
      if( ! self[elem + '_elem'])
        throw new Error("Error! Could not find " + elem + " element");
    }
    var rows = isArray(data.rows) ? data.rows : self.fetchMarkup(),
      cache = {},
      scroll_top = self.scroll_elem.scrollTop;
    self.insertToDOM(rows, cache);
    self.scroll_elem.scrollTop = scroll_top;
    var last_cluster = false,
    scroll_debounce = 0,
    pointer_events_set = false,
    scrollEv = function() {
      if (is_mac) {
        if( ! pointer_events_set) self.content_elem.style.pointerEvents = 'none';
        pointer_events_set = true;
        clearTimeout(scroll_debounce);
        scroll_debounce = setTimeout(function () {
          self.content_elem.style.pointerEvents = 'auto';
          pointer_events_set = false;
        }, 50);
      }
      if (last_cluster != (last_cluster = self.getClusterNum()))
        self.insertToDOM(rows, cache);
      if (self.options.callbacks.scrollingProgress)
        self.options.callbacks.scrollingProgress(self.getScrollProgress());
    },
    resize_debounce = 0,
    resizeEv = function() {
      clearTimeout(resize_debounce);
      resize_debounce = setTimeout(self.refresh, 100);
    }
    on('scroll', self.scroll_elem, scrollEv);
    on('resize', window, resizeEv);
    self.destroy = function(clean) {
      off('scroll', self.scroll_elem, scrollEv);
      off('resize', window, resizeEv);
      self.html((clean ? self.generateEmptyRow() : rows).join(''));
    }
    self.refresh = function(force) {
      if(self.getRowsHeight(rows) || force) self.update(rows);
    }
    self.update = function(new_rows) {
      rows = isArray(new_rows) ? new_rows : [];
      var scroll_top = self.scroll_elem.scrollTop;
      if(rows.length * self.options.item_height < scroll_top) {
        self.scroll_elem.scrollTop = 0;
        last_cluster = 0;
      }
      self.insertToDOM(rows, cache);
      self.scroll_elem.scrollTop = scroll_top;
    }
    self.clear = function() {
      self.update([]);
    }
    self.getRowsAmount = function() {
      return rows.length;
    }
    self.getScrollProgress = function() {
      return this.options.scroll_top / (rows.length * this.options.item_height) * 100 || 0;
    }
    var add = function(where, _new_rows) {
      var new_rows = isArray(_new_rows) ? _new_rows : [];
      if( ! new_rows.length) return;
      rows = where == 'append' ? rows.concat(new_rows) : new_rows.concat(rows);
      self.insertToDOM(rows, cache);
    }
    self.append = function(rows) {
      add('append', rows);
    }
    self.prepend = function(rows) {
      add('prepend', rows);
    }
  }
  Clusterize.prototype = {
    constructor: Clusterize,
    fetchMarkup: function() {
      var rows = [], rows_nodes = this.getChildNodes(this.content_elem);
      while (rows_nodes.length) {
        rows.push(rows_nodes.shift().outerHTML);
      }
      return rows;
    },
    exploreEnvironment: function(rows, cache) {
      var opts = this.options;
      opts.content_tag = this.content_elem.tagName.toLowerCase();
      if( ! rows.length) return;
      if(ie && ie <= 9 && ! opts.tag) opts.tag = rows[0].match(/<([^>\s/]*)/)[1].toLowerCase();
      if(this.content_elem.children.length <= 1) cache.data = this.html(rows[0] + rows[0] + rows[0]);
      if( ! opts.tag) opts.tag = this.content_elem.children[0].tagName.toLowerCase();
      this.getRowsHeight(rows);
    },
    getRowsHeight: function(rows) {
      var opts = this.options, prev_item_height = opts.item_height;
      opts.cluster_height = 0;
      if( ! rows.length) return;
      var nodes = this.content_elem.children;
      if( ! nodes.length) return;
      var node = nodes[Math.floor(nodes.length / 2)];
      opts.item_height = node.offsetHeight;
      if(opts.tag == 'tr' && getStyle('borderCollapse', this.content_elem) != 'collapse')
        opts.item_height += parseInt(getStyle('borderSpacing', this.content_elem), 10) || 0;
      if(opts.tag != 'tr') {
        var marginTop = parseInt(getStyle('marginTop', node), 10) || 0;
        var marginBottom = parseInt(getStyle('marginBottom', node), 10) || 0;
        opts.item_height += Math.max(marginTop, marginBottom);
      }
      opts.block_height = opts.item_height * opts.rows_in_block;
      opts.rows_in_cluster = opts.blocks_in_cluster * opts.rows_in_block;
      opts.cluster_height = opts.blocks_in_cluster * opts.block_height;
      return prev_item_height != opts.item_height;
    },
    getClusterNum: function () {
      this.options.scroll_top = this.scroll_elem.scrollTop;
      return Math.floor(this.options.scroll_top / (this.options.cluster_height - this.options.block_height)) || 0;
    },
    generateEmptyRow: function() {
      var opts = this.options;
      if( ! opts.tag || ! opts.show_no_data_row) return [];
      var empty_row = document.createElement(opts.tag), no_data_content = document.createTextNode(opts.no_data_text), td;
      empty_row.className = opts.no_data_class;
      if(opts.tag == 'tr') {
        td = document.createElement('td');
        td.colSpan = 100;
        td.appendChild(no_data_content);
      }
      empty_row.appendChild(td || no_data_content);
      return [empty_row.outerHTML];
    },
    generate: function (rows, cluster_num) {
      var opts = this.options, rows_len = rows.length;
      if (rows_len < opts.rows_in_block) {
        return {
          top_offset: 0,
          bottom_offset: 0,
          rows_above: 0,
          rows: rows_len ? rows : this.generateEmptyRow()
        }
      }
      var items_start = Math.max((opts.rows_in_cluster - opts.rows_in_block) * cluster_num, 0),
        items_end = items_start + opts.rows_in_cluster,
        top_offset = Math.max(items_start * opts.item_height, 0),
        bottom_offset = Math.max((rows_len - items_end) * opts.item_height, 0),
        this_cluster_rows = [],
        rows_above = items_start;
      if(top_offset < 1) {
        rows_above++;
      }
      for (var i = items_start; i < items_end; i++) {
        rows[i] && this_cluster_rows.push(rows[i]);
      }
      return {
        top_offset: top_offset,
        bottom_offset: bottom_offset,
        rows_above: rows_above,
        rows: this_cluster_rows
      }
    },
    renderExtraTag: function(class_name, height) {
      var tag = document.createElement(this.options.tag),
        clusterize_prefix = 'clusterize-';
      tag.className = [clusterize_prefix + 'extra-row', clusterize_prefix + class_name].join(' ');
      height && (tag.style.height = height + 'px');
      return tag.outerHTML;
    },
    insertToDOM: function(rows, cache) {
      if( ! this.options.cluster_height) {
        this.exploreEnvironment(rows, cache);
      }
      var data = this.generate(rows, this.getClusterNum()),
        this_cluster_rows = data.rows.join(''),
        this_cluster_content_changed = this.checkChanges('data', this_cluster_rows, cache),
        top_offset_changed = this.checkChanges('top', data.top_offset, cache),
        only_bottom_offset_changed = this.checkChanges('bottom', data.bottom_offset, cache),
        callbacks = this.options.callbacks,
        layout_start = callbacks.clusterWillChange,
        layout_end = callbacks.clusterChanged;
      if(this_cluster_content_changed || top_offset_changed) {
        if(data.top_offset) {
          this_cluster_rows = this.renderExtraTag('top', data.top_offset) + this_cluster_rows;
        }
        if(data.bottom_offset) {
          this_cluster_rows += this.renderExtraTag('bottom', data.bottom_offset);
        }
        layout_start && layout_start();
        this.html(this_cluster_rows);
        layout_end && layout_end();
        this.options.content_tag == 'ol' && this.content_elem.setAttribute('start', data.rows_above);
      } else if(only_bottom_offset_changed) {
        this.content_elem.lastChild.style.height = data.bottom_offset + 'px';
      }
    },
    html: function(data) {
      var content_elem = this.content_elem;
      if(ie && ie <= 9 && this.options.tag == 'tr') {
        var div = document.createElement('div'), last;
        div.innerHTML = '<table><tbody>' + data + '</tbody></table>';
        while((last = content_elem.lastChild)) {
          content_elem.removeChild(last);
        }
        var rows_nodes = this.getChildNodes(div.firstChild.firstChild);
        while (rows_nodes.length) {
          content_elem.appendChild(rows_nodes.shift());
        }
      } else {
        content_elem.innerHTML = data;
      }
    },
    getChildNodes: function(tag) {
      var child_nodes = tag.children, nodes = [];
      for (var i = 0, ii = child_nodes.length; i < ii; i++) {
        nodes.push(child_nodes[i]);
      }
      return nodes;
    },
    checkChanges: function(type, value, cache) {
      var changed = value != cache[type];
      cache[type] = value;
      return changed;
    }
  }
  function on(evt, element, fnc) {
    return element.addEventListener ? element.addEventListener(evt, fnc, false) : element.attachEvent("on" + evt, fnc);
  }
  function off(evt, element, fnc) {
    return element.removeEventListener ? element.removeEventListener(evt, fnc, false) : element.detachEvent("on" + evt, fnc);
  }
  function isArray(arr) {
    return Object.prototype.toString.call(arr) === '[object Array]';
  }
  function getStyle(prop, elem) {
    return window.getComputedStyle ? window.getComputedStyle(elem)[prop] : elem.currentStyle[prop];
  }
  return Clusterize;
}));
</script>
</body>
</html>
