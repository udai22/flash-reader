<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>{{ book.title }} - Overhauled Flash Reader</title>

  <style>
    /* ====================== THEME VARIABLES ======================= */
    html[data-theme="light"] {
      --primary-color: #2563eb;
      --text-color: #1f2937;
      --bg-color: #f3f4f6;
      --surface-color: #ffffff;
      --progress-bg: rgba(37, 99, 235, 0.1);
      --progress-fill: rgba(37, 99, 235, 0.9);
      --button-bg: rgba(255, 255, 255, 0.9);
      --button-hover: #ffffff;
    }
    html[data-theme="dark"] {
      --primary-color: #60a5fa;
      --text-color: #e5e7eb;
      --bg-color: #111827;
      --surface-color: #1f2937;
      --progress-bg: rgba(96, 165, 250, 0.1);
      --progress-fill: rgba(96, 165, 250, 0.9);
      --button-bg: rgba(31, 41, 55, 0.9);
      --button-hover: #374151;
    }
    html[data-theme="sand"] {
      --primary-color: #9c4221;
      --text-color: #442c1d;
      --bg-color: #faf0e6;
      --surface-color: #fff8f0;
      --progress-bg: rgba(156, 66, 33, 0.1);
      --progress-fill: rgba(156, 66, 33, 0.9);
      --button-bg: rgba(255, 248, 240, 0.9);
      --button-hover: #fff8f0;
    }

    /* ====================== GLOBAL RESET ======================= */
    body {
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: var(--bg-color);
      color: var(--text-color);
      height: 100vh;
      width: 100vw;
      /* Lock background scroll, so only the context overlay can scroll: */
      overflow: hidden;
      transition: background-color 0.3s, color 0.3s;
    }

    .reader-container {
      position: relative;
      width: 100%;
      height: 100%;
    }

    /* ====================== BACK BUTTON ======================= */
    .back-button {
      position: fixed;
      left: 16px;
      top: 16px;
      padding: 8px 16px;
      background: var(--button-bg);
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-size: 14px;
      z-index: 100;
    }

    /* ============== THEME & WPM CONTROLS ============== */
    .theme-toggle {
      position: fixed;
      right: 16px;
      top: 16px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      z-index: 10002;
    }
    .theme-buttons {
      display: flex;
      gap: 8px;
      background: var(--button-bg);
      padding: 4px;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    .theme-button {
      padding: 8px 12px;
      border: none;
      border-radius: 4px;
      background: transparent;
      color: var(--text-color);
      cursor: pointer;
      font-size: 14px;
    }
    .theme-button.active {
      background: var(--primary-color);
      color: #fff;
    }
    .theme-button:hover:not(.active) {
      background: var(--button-hover);
    }

    .wpm-controls {
      background: var(--button-bg);
      padding: 8px 12px;
      border-radius: 12px;
      display: flex;
      align-items: center;
      gap: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    .wpm-controls button {
      width: 44px;
      height: 44px;
      border: none;
      border-radius: 10px;
      background: var(--bg-color);
      color: var(--text-color);
      cursor: pointer;
    }
    .wpm-value {
      font-size: 16px;
      font-weight: 600;
      min-width: 70px;
      text-align: center;
    }

    .context-mode-button {
      width: 100%;
      padding: 8px 12px;
      background: var(--button-bg);
      border: 1px solid var(--progress-bg);
      border-radius: 8px;
      font-size: 14px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      cursor: pointer;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);

      pointer-events: none; /* disabled until data is loaded */
      opacity: 0.5;        /* visually dimmed */
      transition: opacity 0.2s, pointer-events 0.2s;
    }
    .context-mode-button.active {
      background: var(--primary-color);
      color: #fff;
      border-color: var(--primary-color);
    }

    /* ============== SINGLE-WORD READER ============== */
    .word-boundary {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      border-radius: 12px;
      background: var(--bg-color);
      padding: 40px;
      text-align: center;
      cursor: pointer;
      user-select: none;
    }
    .word-display {
      font-size: 36px;
      font-weight: 500;
    }

    /* ============= PROGRESS BAR & INFO ============= */
    .progress-bar {
      position: fixed;
      left: 0; top: 0; bottom: 0;
      width: 4px;
      background: var(--progress-bg);
      opacity: 0;
      transition: opacity 0.3s;
    }
    .progress-bar.visible { opacity: 1; }
    .progress-fill {
      position: absolute;
      bottom: 0;
      width: 100%;
      background: var(--progress-fill);
      transition: height 0.3s;
    }
    .progress-info {
      position: fixed;
      left: 16px;
      top: 16px;
      background: var(--button-bg);
      padding: 8px 12px;
      border-radius: 8px;
      font-size: 14px;
      opacity: 0;
      transition: opacity 0.3s;
    }
    .progress-info.visible { opacity: 1; }

    /* ============== CONTEXT VIEW OVERLAY ============== */
    .context-view {
      display: none; /* hidden by default */
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: var(--surface-color);
      overflow-y: auto;
      z-index: 9999;
      opacity: 0;
      transition: opacity 0.3s ease-out;
    }
    .context-view.visible {
      display: block;
      opacity: 1;
    }

    .context-header {
      position: sticky;
      top: 0;
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: var(--surface-color);
      border-bottom: 1px solid var(--progress-bg);
      padding: 0 16px;
      height: 60px;
      z-index: 10000;
    }
    .chapters-dropdown {
      position: relative;
      margin-left: 16px;
    }
    .chapters-button,
    .context-undo,
    .context-close-button {
      border: 1px solid var(--progress-bg);
      background: var(--surface-color);
      padding: 8px 12px;
      border-radius: 8px;
      font-size: 14px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .chapters-list {
      position: absolute;
      top: 100%;
      left: 0;
      width: 240px;
      max-height: 60vh;
      background: var(--surface-color);
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
      border-radius: 8px;
      overflow-y: auto;
      opacity: 0;
      pointer-events: none;
      transform: translateY(8px);
      transition: all 0.2s;
      margin-top: 8px;
      z-index: 1003;
    }
    .chapters-list.visible {
      opacity: 1;
      pointer-events: auto;
      transform: translateY(0);
    }
    .chapter-item {
      padding: 12px;
      border-radius: 6px;
      cursor: pointer;
      transition: background 0.2s;
    }
    .chapter-item:hover {
      background: var(--progress-bg);
    }
    .chapter-item.current {
      background: var(--progress-bg);
      color: var(--primary-color);
      font-weight: 500;
    }

    .context-content {
      position: relative;
      width: 100%;
      box-sizing: border-box;
    }
    .top-spacer, .bottom-spacer {
      height: 0;
      width: 100%;
    }
    .chunks-container {
      position: relative;
      width: 100%;
    }
    .virtual-word {
      cursor: pointer;
      padding: 2px 4px;
      border-radius: 4px;
      display: inline-block;
      user-select: text;
      transition: background 0.2s;
    }
    .virtual-word:hover {
      background: var(--progress-bg);
      color: var(--primary-color);
    }
    .current-word {
      background: var(--progress-bg);
      color: var(--primary-color);
      font-weight: 600;
      padding: 2px 4px;
      border-radius: 4px;
      scroll-margin-top: 100px;
    }
    .chapter-indicator {
      display: block;
      text-align: center;
      padding: 20px 0;
      margin: 20px 0;
      border-top: 1px solid var(--progress-bg);
      border-bottom: 1px solid var(--progress-bg);
      color: var(--primary-color);
      font-weight: 500;
      background: var(--surface-color);
    }

    /* ============== WPM INDICATOR ============== */
    .wpm-indicator {
      position: fixed;
      right: 16px;
      top: 80px;
      background: var(--surface-color);
      padding: 8px 16px;
      border-radius: 8px;
      font-size: 16px;
      font-weight: 500;
      opacity: 0;
      transform: translateY(-10px);
      transition: opacity 0.3s, transform 0.3s;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      z-index: 100;
    }
    .wpm-indicator.visible {
      opacity: 1;
      transform: translateY(0);
    }

    /* ============== PROGRESS NAV (RIGHT) ============== */
    .progress-nav {
      position: fixed;
      right: 24px;
      top: 120px;
      bottom: 80px;
      width: 12px;
      background: var(--progress-bg);
      border-radius: 6px;
      cursor: pointer;
      z-index: 90;
    }
    .progress-nav-fill {
      position: absolute;
      bottom: 0; left: 0;
      width: 100%;
      background: var(--progress-fill);
      border-radius: 4px;
      transition: height 0.1s;
    }
    .progress-nav-tooltip {
      position: absolute;
      right: 24px;
      background: var(--surface-color);
      padding: 8px 12px;
      border-radius: 8px;
      font-size: 14px;
      white-space: nowrap;
      transform: translateY(-50%);
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      pointer-events: none;
      transition: opacity 0.2s;
      opacity: 1;
    }
    .word-preview {
      color: var(--primary-color);
      font-weight: 500;
    }

    /* Hide theme toggle, progress info, etc. when context overlay is shown */
    .context-view.visible ~ .progress-bar,
    .context-view.visible ~ .progress-info,
    .context-view.visible ~ .theme-toggle,
    .context-view.visible ~ .wpm-indicator {
      display: none;
    }
  </style>
</head>
<body>
<div class="reader-container">
  <!-- ============== BACK BUTTON ============== -->
  <button class="back-button" onclick="window.location.href='/'">← Back</button>

  <!-- ============== THEME & WPM CONTROLS ============== -->
  <div class="theme-toggle">
    <div class="theme-buttons">
      <button class="theme-button active" data-theme="light">Light</button>
      <button class="theme-button" data-theme="dark">Dark</button>
      <button class="theme-button" data-theme="sand">Sand</button>
    </div>
    <div class="wpm-controls">
      <button onclick="updateWPM(state.currentWPM - 25)">-25</button>
      <div class="wpm-value"><span id="wpmValueTop">300</span> WPM</div>
      <button onclick="updateWPM(state.currentWPM + 25)">+25</button>
    </div>
    <button class="context-mode-button" id="contextModeButton" onclick="toggleContextView()">
      <svg width="16" height="16" viewBox="0 0 24 24" stroke="currentColor" fill="none">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
              d="M4 6h16M4 12h16M4 18h16"/>
      </svg>
      <span>Context View</span>
    </button>
  </div>

  <!-- ============== PROGRESS BAR / INFO ============== -->
  <div class="progress-bar" id="progressBar">
    <div class="progress-fill" id="progressFill"></div>
  </div>
  <div class="progress-info" id="progressInfo">
    <div>Chapter <span id="chapterNumber">1</span></div>
    <div>Page <span id="pageNumber">1</span></div>
    <div><span id="progressPercent">0</span>%</div>
  </div>

  <!-- ============== SINGLE WORD DISPLAY ============== -->
  <div class="word-boundary" id="wordBoundary">
    <div class="word-display" id="wordDisplay">Tap to start reading</div>
  </div>

  <!-- ============== WPM INDICATOR ============== -->
  <div class="wpm-indicator" id="wpmIndicator">
    <span id="wpmIndicatorValue">300</span> WPM
  </div>

  <!-- ============== CONTEXT VIEW ============== -->
  <div class="context-view" id="contextView">
    <div class="context-header">
      <div class="chapters-dropdown">
        <button class="chapters-button" onclick="toggleChaptersList()">Chapters</button>
        <div class="chapters-list" id="chaptersList"></div>
      </div>
      <button class="context-undo" onclick="undoLastPosition()">Undo</button>
      <button class="context-close-button" onclick="hideContextView()">Close</button>
    </div>
    <div class="context-content" id="contextContent">
      <div class="top-spacer" id="topSpacer"></div>
      <div class="chunks-container" id="chunksContainer"></div>
      <div class="bottom-spacer" id="bottomSpacer"></div>
    </div>
  </div>

  <!-- ============== PROGRESS NAV (RIGHT) ============== -->
  <div class="progress-nav" id="progressNav">
    <div class="progress-nav-fill" id="progressNavFill"></div>
    <div class="progress-nav-tooltip" id="progressNavTooltip">
      <div>Word <span id="wordNumber">0</span> / <span id="totalWords">0</span></div>
      <div class="word-preview" id="wordPreview"></div>
    </div>
  </div>
</div>

<script>
'use strict';

/* ========================================================================
   GLOBAL STATE
========================================================================= */
const state = {
  isPlaying: false,
  currentIndex: 0,
  words: [],
  chapters: [],
  undoStack: [],

  // WPM + Reading
  currentWPM: parseInt(localStorage.getItem('reader-wpm'), 10) || 300,
  readingInterval: null,
  minWPM: 100,
  maxWPM: 1200,

  // Context
  contextViewActive: false,
  wasPlayingBeforeContext: false,

  // Throttle saving
  saveTimeout: null,

  // Chunk-based "virtual scroll"
  chunkSize: 500,
  chunkedData: [], // each item: { startIndex, endIndex, html, exactHeight }
  topPadding: 0,
  bottomPadding: 0,
  chunksMeasured: false,
};


/* ========================================================================
   MAIN SETUP
========================================================================= */
document.addEventListener('DOMContentLoaded', async () => {
  try {
    console.log('[INIT] DOMContentLoaded - starting main setup');

    // Optional: wait for font loading
    if (document.fonts && document.fonts.ready) {
      console.log('[INIT] Waiting for document.fonts.ready...');
      await document.fonts.ready.catch(() => {});
      console.log('[INIT] Fonts loaded (or skip due to catch).');
    }

    // Fetch book content
    console.log('[INIT] Fetching book content from /api/book/{{ book.id }}/content');
    const resp = await fetch(`/api/book/{{ book.id }}/content`);
    if (!resp.ok) {
      throw new Error('Failed to fetch book content');
    }
    const data = await resp.json();
    console.log('[INIT] Book content fetched successfully:', data);

    // Tokenize content
    const rawContent = data.content || '';
    const tokens = rawContent.match(/\w+|\S/g) || [];
    state.words = tokens;
    console.log(`[INIT] Tokenized total words: ${state.words.length}`);

    // Current position
    const pos = parseInt(data.current_position, 10) || 0;
    state.currentIndex = Math.min(Math.max(pos, 0), state.words.length - 1);
    console.log(`[INIT] Current position set to: ${state.currentIndex}`);

    // Chapters
    state.chapters = data.chapters || [];
    console.log('[INIT] Loaded chapters:', state.chapters);

    // Build chunk data
    buildChunksOnly();

    // Initialize UI
    updateAllUI();
    setupEventListeners();
    setupProgressNav();

    // Now that everything loaded, enable context button
    const ctxBtn = document.getElementById('contextModeButton');
    ctxBtn.style.pointerEvents = 'auto';
    ctxBtn.style.opacity = '1';
    console.log('[INIT] Context mode button enabled. Setup complete.');

  } catch (err) {
    console.error('Error during initialization:', err);
  }
});


/* ========================================================================
   CHUNK BUILDING & MEASUREMENT
========================================================================= */
function buildChunksOnly() {
  console.log('[buildChunksOnly] Building chunk data...');
  state.chunkedData = [];
  
  // Estimate average characters per line (based on common reading widths)
  const CHARS_PER_LINE = 60;
  const LINES_PER_VIEWPORT = 20;
  const CHARS_PER_CHUNK = CHARS_PER_LINE * LINES_PER_VIEWPORT;
  
  for (let i = 0; i < state.words.length; i += state.chunkSize) {
    const startIndex = i;
    const endIndex = Math.min(i + state.chunkSize, state.words.length);
    const slice = state.words.slice(startIndex, endIndex);

    // Calculate estimated height based on text content
    const chunkText = slice.join(' ');
    const estimatedLines = Math.ceil(chunkText.length / CHARS_PER_LINE);
    const estimatedHeight = estimatedLines * 24; // Assume 24px line height

    const chunkHTML = buildChunkHTML(slice, startIndex, false);
    state.chunkedData.push({
      startIndex,
      endIndex,
      html: chunkHTML,
      exactHeight: estimatedHeight // Start with estimated height
    });
  }
  console.log(`[buildChunksOnly] Total chunks created: ${state.chunkedData.length}`);
}

function measureAllChunks() {
  if (state.chunksMeasured) {
    console.log('[measureAllChunks] Already measured. Skipping...');
    return;
  }
  console.log('[measureAllChunks] Starting measurement of all chunks...');

  // Try to measure a test element first
  const canMeasure = testLayoutMeasurement();
  if (!canMeasure) {
    console.log('[measureAllChunks] Layout measurement blocked. Using estimated heights.');
    state.chunksMeasured = true;
    return; // Keep using the estimated heights we set in buildChunksOnly
  }

  const contextContent = document.getElementById('contextContent');
  const measureContainer = document.createElement('div');
  measureContainer.style.cssText = `
    position: absolute;
    visibility: hidden;
    top: -9999px;
    left: -9999px;
    width: ${contextContent.clientWidth}px;
    padding: 0 20px;
    box-sizing: border-box;
  `;
  contextContent.appendChild(measureContainer);

  let gotAnyNonZero = false;
  for (let i = 0; i < state.chunkedData.length; i++) {
    const chunk = state.chunkedData[i];
    const div = document.createElement('div');
    div.innerHTML = chunk.html;
    measureContainer.appendChild(div);

    const rect = div.getBoundingClientRect();
    if (rect.height > 0) {
      gotAnyNonZero = true;
      chunk.exactHeight = rect.height;
    }
    // If height is 0, keep the estimated height we set earlier
    
    measureContainer.removeChild(div);
  }

  contextContent.removeChild(measureContainer);
  
  if (!gotAnyNonZero) {
    console.warn('[measureAllChunks] All measurements returned 0. Using estimated heights.');
  } else {
    console.log('[measureAllChunks] Successfully measured chunk heights.');
  }
  
  state.chunksMeasured = true;
}

function testLayoutMeasurement() {
  try {
    const test = document.createElement('div');
    test.textContent = 'test';
    test.style.cssText = 'position:absolute;visibility:hidden;';
    document.body.appendChild(test);
    const rect = test.getBoundingClientRect();
    document.body.removeChild(test);
    return rect.height > 0;
  } catch (e) {
    console.warn('[testLayoutMeasurement] Layout measurement not available:', e);
    return false;
  }
}

function buildChunkHTML(wordArray, offset, highlightCurrent) {
  let html = '';
  let chapterIndex = getChapterIndexForWord(offset);
  let nextChapterPos =
    (chapterIndex < state.chapters.length) ? state.chapters[chapterIndex].position : -1;
  let chapterTitle =
    (chapterIndex < state.chapters.length) ? state.chapters[chapterIndex].title : null;

  for (let i = 0; i < wordArray.length; i++) {
    const globalIndex = offset + i;

    // Insert chapter indicator if needed
    if (chapterIndex < state.chapters.length && globalIndex === nextChapterPos) {
      html += `<div class="chapter-indicator">${chapterTitle}</div>`;
      chapterIndex++;
      if (chapterIndex < state.chapters.length) {
        nextChapterPos = state.chapters[chapterIndex].position;
        chapterTitle = state.chapters[chapterIndex].title;
      } else {
        nextChapterPos = -1;
      }
    }

    // Highlight if current word
    let classes = 'virtual-word';
    if (highlightCurrent && globalIndex === state.currentIndex) {
      classes = 'current-word';
    }

    html += `<span class="${classes}" data-index="${globalIndex}">${wordArray[i]}</span> `;
  }

  return html;
}


/* ========================================================================
   EVENT LISTENERS & UI
========================================================================= */
function setupEventListeners() {
  console.log('[setupEventListeners] Setting up...');
  const wb = document.getElementById('wordBoundary');
  wb.addEventListener('click', () => {
    if (!state.contextViewActive) {
      toggleReading();
    }
  });

  document.addEventListener('keydown', (e) => {
    switch (e.code) {
      case 'Space':
        e.preventDefault();
        toggleReading();
        break;
      case 'ArrowUp':
        e.preventDefault();
        updateWPM(state.currentWPM + 25);
        break;
      case 'ArrowDown':
        e.preventDefault();
        updateWPM(state.currentWPM - 25);
        break;
      case 'ArrowLeft':
        e.preventDefault();
        jumpWords(-10);
        break;
      case 'ArrowRight':
        e.preventDefault();
        jumpWords(10);
        break;
      case 'PageUp':
        e.preventDefault();
        jumpWords(-100);
        break;
      case 'PageDown':
        e.preventDefault();
        jumpWords(100);
        break;
      default:
        // no-op
        break;
    }
  });

  // Theme buttons
  const themeBtns = document.querySelectorAll('.theme-button');
  themeBtns.forEach((btn) => {
    btn.addEventListener('click', () => {
      setTheme(btn.dataset.theme);
    });
  });
  setTheme(localStorage.getItem('reader-theme') || 'light');

  // Scroll in context view
  document.getElementById('contextContent').addEventListener('scroll', onContextScroll);

  // Click on word in chunks
  document.getElementById('chunksContainer').addEventListener('click', (e) => {
    if (e.target.matches('.virtual-word') || e.target.matches('.current-word')) {
      const i = parseInt(e.target.dataset.index, 10);
      if (!isNaN(i)) {
        console.log(`[chunksContainer click] Jumping from index ${state.currentIndex} to ${i}`);
        pushToUndoStack(state.currentIndex);
        state.currentIndex = i;
        updateAllUI();
        renderVisibleChunks();
        scrollCurrentWordIntoView();
      }
    }
  });
}

function updateAllUI() {
  console.log('[updateAllUI] Updating main UI elements...');
  const display = document.getElementById('wordDisplay');
  display.textContent = state.words[state.currentIndex] || '';

  updateProgress();
  updateProgressNav();
  document.getElementById('wpmValueTop').textContent = state.currentWPM.toString();

  const c = findChapterForIndex(state.currentIndex);
  document.getElementById('chapterNumber').textContent = c ? c.title : 'N/A';

  // Throttle saving
  saveProgress(false);
}


/* ========================================================================
   READING CONTROL
========================================================================= */
function toggleReading() {
  if (state.isPlaying) {
    console.log('[toggleReading] Pausing...');
    pauseReading();
    document.getElementById('progressNavTooltip').style.opacity = '1';
  } else {
    console.log('[toggleReading] Starting reading...');
    startReading();
    document.getElementById('progressNavTooltip').style.opacity = '0';
  }
}

function startReading() {
  pauseReading();
  state.isPlaying = true;
  console.log('[startReading] Reading started. Current index:', state.currentIndex);

  const intervalMS = 60000 / state.currentWPM;
  const disp = document.getElementById('wordDisplay');
  disp.textContent = state.words[state.currentIndex] || '';

  state.readingInterval = setInterval(() => {
    if (state.currentIndex >= state.words.length - 1) {
      console.log('[startReading] Reached end of words. Stopping.');
      pauseReading();
      return;
    }
    state.currentIndex++;
    disp.textContent = state.words[state.currentIndex] || '';
    updateProgress();
    updateProgressNav();
    saveProgress(false);
  }, intervalMS);
}

function pauseReading() {
  state.isPlaying = false;
  if (state.readingInterval) {
    clearInterval(state.readingInterval);
    state.readingInterval = null;
  }
  console.log('[pauseReading] Reading paused.');
}

function jumpWords(offset) {
  const oldIndex = state.currentIndex;
  let newIndex = oldIndex + offset;
  newIndex = Math.max(0, Math.min(newIndex, state.words.length - 1));
  console.log(`[jumpWords] Jumping from ${oldIndex} to ${newIndex} (offset ${offset}).`);
  pushToUndoStack(oldIndex);
  state.currentIndex = newIndex;
  updateAllUI();

  if (state.isPlaying) {
    pauseReading();
    startReading();
  }
  if (state.contextViewActive) {
    renderVisibleChunks();
    scrollCurrentWordIntoView();
  }
}


/* ========================================================================
   PROGRESS INFO
========================================================================= */
function updateProgress() {
  const fill = document.getElementById('progressFill');
  const percentEl = document.getElementById('progressPercent');

  if (state.words.length > 1) {
    const ratio = state.currentIndex / (state.words.length - 1);
    const pct = Math.round(ratio * 100);
    fill.style.height = pct + '%';
    percentEl.textContent = String(pct);
  } else {
    fill.style.height = '0%';
    percentEl.textContent = '0';
  }
}


/* ========================================================================
   SAVE PROGRESS
========================================================================= */
function saveProgress(immediate) {
  if (immediate) {
    doSaveProgress();
    return;
  }
  if (state.saveTimeout) {
    clearTimeout(state.saveTimeout);
  }
  state.saveTimeout = setTimeout(() => {
    doSaveProgress();
  }, 1000);
}

async function doSaveProgress() {
  localStorage.setItem('reader-wpm', state.currentWPM);
  localStorage.setItem(`book-{{ book.id }}-position`, state.currentIndex);
  console.log(`[doSaveProgress] Saving position = ${state.currentIndex}, WPM = ${state.currentWPM}`);

  try {
    await fetch(`/api/book/{{ book.id }}/position`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ position: state.currentIndex, wpm: state.currentWPM })
    });
    console.log('[doSaveProgress] Progress saved to server.');
  } catch (err) {
    console.warn('Could not save progress:', err);
  }
}


/* ========================================================================
   WPM CONTROL
========================================================================= */
let wpmIndicatorTimer;
function updateWPM(val) {
  const oldWPM = state.currentWPM;
  const w = Math.max(state.minWPM, Math.min(state.maxWPM, val));
  state.currentWPM = w;
  console.log(`[updateWPM] Changed from ${oldWPM} -> ${w}`);

  document.getElementById('wpmValueTop').textContent = String(w);
  document.getElementById('wpmIndicatorValue').textContent = String(w);
  showWPMIndicator();

  if (state.isPlaying) {
    pauseReading();
    startReading();
  }
}

function showWPMIndicator() {
  const ind = document.getElementById('wpmIndicator');
  ind.classList.add('visible');
  if (wpmIndicatorTimer) {
    clearTimeout(wpmIndicatorTimer);
  }
  wpmIndicatorTimer = setTimeout(() => {
    ind.classList.remove('visible');
  }, 1500);
}


/* ========================================================================
   CONTEXT VIEW TOGGLE
========================================================================= */
function toggleContextView() {
  if (state.contextViewActive) {
    hideContextView();
  } else {
    showContextView();
  }
}

function showContextView() {
  console.log('[showContextView] Toggling ON context view...');
  state.wasPlayingBeforeContext = state.isPlaying;
  if (state.isPlaying) {
    pauseReading();
  }

  // Set active state first
  state.contextViewActive = true;
  
  // Ensure chunks are ready (measured or estimated)
  if (!state.chunksMeasured) {
    measureAllChunks();
  }

  const cv = document.getElementById('contextView');
  const content = document.getElementById('contextContent');

  // Set initial styles for smooth transition
  cv.style.display = 'block';
  content.style.cssText = `
    padding: 0 20px;
    box-sizing: border-box;
    max-width: 800px;
    margin: 0 auto;
    line-height: 1.6;
  `;

  // Show the view and render content
  requestAnimationFrame(() => {
    cv.classList.add('visible');
    renderVisibleChunks();
    
    // Scroll to current word after render
    requestAnimationFrame(() => {
      scrollCurrentWordIntoView(false);
    });
  });

  const btn = document.getElementById('contextModeButton');
  btn.classList.add('active');
  btn.innerHTML = `
    <svg width="16" height="16" viewBox="0 0 24 24" stroke="currentColor" fill="none">
      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
            d="M6 18L18 6M6 6l12 12"/>
    </svg>
    <span>Close View</span>
  `;
}

function hideContextView() {
  console.log('[hideContextView] Toggling OFF context view...');
  state.contextViewActive = false;
  
  const cv = document.getElementById('contextView');
  cv.classList.remove('visible');
  
  // Important: Set display none AFTER a short delay to allow transition
  setTimeout(() => {
    if (!state.contextViewActive) { // Double check state hasn't changed
      cv.style.display = 'none';
    }
  }, 300); // Match transition duration from CSS

  if (state.wasPlayingBeforeContext) {
    startReading();
  }
  state.wasPlayingBeforeContext = false;

  // Restore single-word display
  document.getElementById('wordDisplay').textContent =
    state.words[state.currentIndex] || '';

  const btn = document.getElementById('contextModeButton');
  btn.classList.remove('active');
  btn.innerHTML = `
    <svg width="16" height="16" viewBox="0 0 24 24" stroke="currentColor" fill="none">
      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
            d="M4 6h16M4 12h16M4 18h16"/>
    </svg>
    <span>Context View</span>
  `;
  console.log('[hideContextView] Context view hidden.');
}


/* ========================================================================
   CONTEXT SCROLL & RENDER
========================================================================= */
function onContextScroll() {
  if (!state.chunksMeasured) {
    console.warn('[onContextScroll] Chunks not measured yet. Not rendering.');
    return;
  }
  renderVisibleChunks();
}

function renderVisibleChunks() {
  console.log('[renderVisibleChunks] Start...');
  const container = document.getElementById('contextContent');
  const scrollTop = container.scrollTop;
  const viewHeight = container.clientHeight;

  // Determine which chunk is at top
  let startIndexChunk = 0;
  let accumulated = 0;
  for (let i = 0; i < state.chunkedData.length; i++) {
    const cData = state.chunkedData[i];
    if (accumulated + cData.exactHeight > scrollTop) {
      startIndexChunk = i;
      break;
    }
    accumulated += cData.exactHeight;
  }

  // Collect visible chunks
  const visibleChunks = [];
  let usedHeight = 0;
  let j = startIndexChunk;
  while (j < state.chunkedData.length && usedHeight < viewHeight * 1.5) {
    visibleChunks.push(state.chunkedData[j]);
    usedHeight += state.chunkedData[j].exactHeight;
    j++;
  }

  state.topPadding = accumulated;
  let bottomAccum = 0;
  for (let k = j; k < state.chunkedData.length; k++) {
    bottomAccum += state.chunkedData[k].exactHeight;
  }
  state.bottomPadding = bottomAccum;

  console.log(`[renderVisibleChunks] startIndexChunk=${startIndexChunk}, visibleChunks=${visibleChunks.length}, topPadding=${state.topPadding}, bottomPadding=${state.bottomPadding}`);

  let finalHTML = '';
  for (let i = 0; i < visibleChunks.length; i++) {
    const chunk = visibleChunks[i];
    const highlight = (
      state.currentIndex >= chunk.startIndex && state.currentIndex < chunk.endIndex
    );

    // Rebuild chunk HTML so we highlight the current word if it's in range
    chunk.html = buildChunkHTML(
      state.words.slice(chunk.startIndex, chunk.endIndex),
      chunk.startIndex,
      highlight
    );
    finalHTML += `<div data-chunk-start="${chunk.startIndex}">${chunk.html}</div>`;
  }

  document.getElementById('chunksContainer').innerHTML = finalHTML;
  document.getElementById('topSpacer').style.height = state.topPadding + 'px';
  document.getElementById('bottomSpacer').style.height = state.bottomPadding + 'px';

  console.log('[renderVisibleChunks] Render complete.');
}

function scrollCurrentWordIntoView(smooth) {
  const doSmooth = (typeof smooth === 'boolean') ? smooth : true;
  console.log(`[scrollCurrentWordIntoView] Called with smooth=${doSmooth}`);
  requestAnimationFrame(() => {
    const currentEl = document.querySelector('.current-word');
    if (currentEl) {
      currentEl.scrollIntoView({
        block: 'center',
        behavior: doSmooth ? 'smooth' : 'auto'
      });
      console.log('[scrollCurrentWordIntoView] Scrolled current word into view.');
    } else {
      console.log('[scrollCurrentWordIntoView] No .current-word found.');
    }
  });
}


/* ========================================================================
   CHAPTERS
========================================================================= */
function toggleChaptersList() {
  console.log('[toggleChaptersList] Toggle chapters list...');
  const list = document.getElementById('chaptersList');
  list.classList.toggle('visible');
  if (list.classList.contains('visible')) {
    updateChaptersList();
  }
}

function updateChaptersList() {
  console.log('[updateChaptersList] Building chapters list...');
  const list = document.getElementById('chaptersList');
  list.innerHTML = '';

  for (let i = 0; i < state.chapters.length; i++) {
    const chap = state.chapters[i];
    const nextPos = (i < state.chapters.length - 1)
      ? state.chapters[i + 1].position
      : state.words.length;

    const inThisChapter =
      (state.currentIndex >= chap.position && state.currentIndex < nextPos);

    let progress = 0;
    if (inThisChapter) {
      const chapterSize = nextPos - chap.position;
      const offset = state.currentIndex - chap.position;
      progress = Math.round((offset / chapterSize) * 100);
    } else if (state.currentIndex >= nextPos) {
      progress = 100;
    }

    const div = document.createElement('div');
    div.className = 'chapter-item' + (inThisChapter ? ' current' : '');
    div.innerHTML = `${chap.title} <span style="float:right;">${progress}%</span>`;
    div.onclick = () => {
      console.log(`[updateChaptersList] Jumping to chapter pos=${chap.position}`);
      jumpToChapter(chap.position);
    };
    list.appendChild(div);
  }
}

function jumpToChapter(pos) {
  pushToUndoStack(state.currentIndex);
  state.currentIndex = pos;
  console.log(`[jumpToChapter] Jumping to index=${pos}`);
  updateAllUI();
  renderVisibleChunks();
  scrollCurrentWordIntoView();
  document.getElementById('chaptersList').classList.remove('visible');
}

function findChapterForIndex(idx) {
  for (let i = 0; i < state.chapters.length; i++) {
    const chap = state.chapters[i];
    const nextPos = (i < state.chapters.length - 1)
      ? state.chapters[i+1].position
      : state.words.length;
    if (idx >= chap.position && idx < nextPos) {
      return chap;
    }
  }
  return null;
}

function getChapterIndexForWord(globalIndex) {
  let cIndex = 0;
  for (let i = 0; i < state.chapters.length; i++) {
    const nextPos = (i < state.chapters.length - 1)
      ? state.chapters[i+1].position
      : state.words.length;
    if (globalIndex >= state.chapters[i].position && globalIndex < nextPos) {
      cIndex = i;
      break;
    }
  }
  return cIndex;
}


/* ========================================================================
   UNDO STACK
========================================================================= */
function pushToUndoStack(pos) {
  state.undoStack.push(pos);
  if (state.undoStack.length > 20) {
    state.undoStack.shift();
  }
  console.log('[pushToUndoStack] Stack size now:', state.undoStack.length);
}

function undoLastPosition() {
  if (state.undoStack.length > 0) {
    const last = state.undoStack.pop();
    console.log(`[undoLastPosition] Undoing to pos=${last}`);
    state.currentIndex = last;
    updateAllUI();
    if (state.contextViewActive) {
      renderVisibleChunks();
      scrollCurrentWordIntoView();
    }
  } else {
    console.log('[undoLastPosition] No previous position in stack.');
  }
}


/* ========================================================================
   THEME
========================================================================= */
function setTheme(theme) {
  console.log(`[setTheme] Setting theme to: ${theme}`);
  document.documentElement.setAttribute('data-theme', theme);
  localStorage.setItem('reader-theme', theme);

  const btns = document.querySelectorAll('.theme-button');
  btns.forEach((btn) => {
    btn.classList.toggle('active', btn.dataset.theme === theme);
  });
}


/* ========================================================================
   PROGRESS NAV
========================================================================= */
function setupProgressNav() {
  console.log('[setupProgressNav] Initializing progress nav...');
  const nav = document.getElementById('progressNav');
  const fill = document.getElementById('progressNavFill');
  const tooltip = document.getElementById('progressNavTooltip');
  const wordDisp = document.getElementById('wordDisplay');

  let isDragging = false;

  function updateFromY(clientY) {
    const rect = nav.getBoundingClientRect();
    let ratio = 1 - (clientY - rect.top) / rect.height;
    ratio = Math.max(0, Math.min(ratio, 1));

    let i = Math.floor(ratio * (state.words.length - 1));
    i = Math.max(0, Math.min(i, state.words.length - 1));

    const pct = Math.round((i / (state.words.length - 1)) * 100);
    fill.style.height = pct + '%';

    tooltip.innerHTML = `
      <div>Word ${i + 1} / ${state.words.length} (${pct}%)</div>
      <div class="word-preview">${state.words[i] || ''}</div>
    `;

    // Position tooltip
    const tRect = tooltip.getBoundingClientRect();
    let tY = clientY - (tRect.height / 2);
    const minY = rect.top;
    const maxY = rect.bottom - tRect.height;
    if (tY < minY) tY = minY;
    if (tY > maxY) tY = maxY;
    tooltip.style.top = tY + 'px';

    wordDisp.textContent = state.words[i] || '';
    return i;
  }

  function onDragStart(e) {
    console.log('[progressNav] Drag start');
    isDragging = true;
    if (state.isPlaying) {
      pauseReading();
    }
    onDragMove(e);
  }

  function onDragMove(e) {
    if (!isDragging) return;
    e.preventDefault();
    const clientY = e.type.includes('touch')
      ? e.touches[0].clientY
      : e.clientY;
    state.currentIndex = updateFromY(clientY);
    updateProgressNav();
  }

  function onDragEnd() {
    if (!isDragging) return;
    console.log('[progressNav] Drag end');
    isDragging = false;
    saveProgress(false);

    if (state.contextViewActive) {
      renderVisibleChunks();
      scrollCurrentWordIntoView(false);
    }
  }

  nav.addEventListener('mousedown', onDragStart);
  document.addEventListener('mousemove', onDragMove);
  document.addEventListener('mouseup', onDragEnd);

  nav.addEventListener('touchstart', onDragStart, { passive: false });
  document.addEventListener('touchmove', onDragMove, { passive: false });
  document.addEventListener('touchend', onDragEnd);
  document.addEventListener('touchcancel', onDragEnd);

  // Press "N" to toggle nav visibility
  document.addEventListener('keydown', (e) => {
    if (e.key.toLowerCase() === 'n') {
      const style = window.getComputedStyle(nav);
      const op = style.opacity;
      nav.style.opacity = (op === '1') ? '0' : '1';
      console.log(`[progressNav] "N" pressed. Toggled nav opacity to: ${nav.style.opacity}`);
    }
  });

  tooltip.style.opacity = '1';
  console.log('[setupProgressNav] Done.');
}

function updateProgressNav() {
  if (state.words.length < 2) return;
  const ratio = state.currentIndex / (state.words.length - 1);
  const pct = ratio * 100;
  document.getElementById('progressNavFill').style.height = pct + '%';

  document.getElementById('wordNumber').textContent = (state.currentIndex + 1).toString();
  document.getElementById('totalWords').textContent = state.words.length.toString();
  document.getElementById('wordPreview').textContent =
    state.words[state.currentIndex] || '';
  // console.log(`[updateProgressNav] Updated fill to ${pct}%`);
}
</script>
</body>
</html>
