<!DOCTYPE html>
<!--
    Flash Reader - Simplified, Stable Reading Interface
    - Single content load (no partial/infinite loading)
    - Speed reading with adjustable WPM
    - Context view with entire text shown
    - Chapter navigation + Undo
    - Theme customization (light/dark/sand)
    - Progress tracking + vertical progress nav
    - Simple, explicit interactions (tap/click, no pinch)
    - Desktop & mobile friendly
-->
<html lang="en" data-theme="light">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>{{ book.title }} - Flash Reader</title>

  <style>
    /* ------------------------------------------------------
       THEME VARIABLES
       ------------------------------------------------------ */
    html[data-theme="light"] {
      --primary-color: #2563eb;
      --text-color: #1f2937;
      --bg-color: #f3f4f6;
      --surface-color: #ffffff;
      --progress-bg: rgba(37, 99, 235, 0.1);
      --progress-fill: rgba(37, 99, 235, 0.9);
      --button-bg: rgba(255, 255, 255, 0.9);
      --button-hover: #ffffff;
    }

    html[data-theme="dark"] {
      --primary-color: #60a5fa;
      --text-color: #e5e7eb;
      --bg-color: #111827;
      --surface-color: #1f2937;
      --progress-bg: rgba(96, 165, 250, 0.1);
      --progress-fill: rgba(96, 165, 250, 0.9);
      --button-bg: rgba(31, 41, 55, 0.9);
      --button-hover: #374151;
    }

    html[data-theme="sand"] {
      --primary-color: #9c4221;
      --text-color: #442c1d;
      --bg-color: #faf0e6;
      --surface-color: #fff8f0;
      --progress-bg: rgba(156, 66, 33, 0.1);
      --progress-fill: rgba(156, 66, 33, 0.9);
      --button-bg: rgba(255, 248, 240, 0.9);
      --button-hover: #fff8f0;
    }

    body {
      margin: 0;
      padding: 0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: var(--bg-color);
      color: var(--text-color);
      overflow: hidden; /* We'll manage overflow for the context view */
      height: 100vh;
      width: 100vw;
      transition: background-color 0.3s, color 0.3s;
    }

    /* ------------------------------------------------------
       THEME TOGGLE & WPM CONTROLS (TOP RIGHT)
       ------------------------------------------------------ */
    .theme-toggle {
      position: fixed;
      right: 16px;
      top: 16px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      z-index: 10002;
    }

    .theme-buttons {
      display: flex;
      gap: 8px;
      background: var(--button-bg);
      padding: 4px;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }

    .theme-button {
      padding: 8px 12px;
      border: none;
      border-radius: 4px;
      background: transparent;
      color: var(--text-color);
      cursor: pointer;
      font-size: 14px;
      transition: background-color 0.2s;
    }

    .theme-button.active {
      background: var(--primary-color);
      color: white;
    }

    .theme-button:hover:not(.active) {
      background: var(--button-hover);
    }

    .wpm-controls {
      background: var(--button-bg);
      padding: 8px 12px;
      border-radius: 12px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .wpm-controls button {
      width: 44px;
      height: 44px;
      border: none;
      border-radius: 10px;
      background: var(--bg-color);
      color: var(--text-color);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
      position: relative;
      padding: 0;
    }

    .wpm-controls button svg {
      width: 20px;
      height: 20px;
      stroke-width: 2.5;
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
    }

    .wpm-controls button:active {
      background: var(--primary-color);
      color: white;
      transform: scale(0.95);
    }

    .wpm-controls .wpm-value {
      padding: 0 8px;
      font-weight: 600;
      font-size: 16px;
      color: var(--text-color);
      min-width: 90px;
      text-align: center;
      font-variant-numeric: tabular-nums;
    }

    /* ------------------------------------------------------
       CONTEXT MODE BUTTON (IN THEME TOGGLE)
       ------------------------------------------------------ */
    .context-mode-button {
      margin-top: 8px;
      width: 100%;
      padding: 8px 12px;
      background: var(--button-bg);
      border: 1px solid var(--progress-bg);
      border-radius: 8px;
      color: var(--text-color);
      font-size: 14px;
      font-weight: 500;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }
    .context-mode-button:hover {
      background: var(--button-hover);
    }
    .context-mode-button.active {
      background: var(--primary-color);
      color: white;
      border-color: var(--primary-color);
    }

    /* ------------------------------------------------------
       READER CONTAINER
       ------------------------------------------------------ */
    .reader-container {
      position: relative;
      width: 100%;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    /* BACK BUTTON */
    .back-button {
      position: fixed;
      left: 16px;
      top: 16px;
      padding: 8px 16px;
      background: rgba(255, 255, 255, 0.9);
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-size: 14px;
      color: var(--text-color);
      z-index: 100;
    }
    .back-button:hover {
      background: white;
    }

    /* ------------------------------------------------------
       PROGRESS BAR (LEFT SIDE)
       ------------------------------------------------------ */
    .progress-bar {
      position: fixed;
      left: 0;
      top: 0;
      bottom: 0;
      width: 4px;
      background: var(--progress-bg);
      opacity: 0; /* becomes visible if desired */
      transition: opacity 0.3s;
    }
    .progress-bar.visible {
      opacity: 1;
    }
    .progress-fill {
      position: absolute;
      bottom: 0;
      width: 100%;
      background: var(--progress-fill);
      transition: height 0.3s;
    }

    .progress-info {
      position: fixed;
      left: 16px;
      top: 16px;
      background: rgba(255, 255, 255, 0.9);
      padding: 8px 12px;
      border-radius: 8px;
      font-size: 14px;
      opacity: 0;
      transition: opacity 0.3s;
    }
    .progress-info.visible {
      opacity: 1;
    }

    /* ------------------------------------------------------
       WORD DISPLAY (CENTER)
       ------------------------------------------------------ */
    .word-boundary {
      position: relative;
      padding: 40px;
      border-radius: 12px;
      background: rgba(var(--bg-color-rgb), 0.1);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transform: translateZ(0);
      -webkit-backface-visibility: hidden;
      backface-visibility: hidden;
      will-change: transform;
    }

    .word-display {
      font-size: 36px;
      font-weight: 500;
      text-align: center;
      user-select: none;
      transition: opacity 0.3s ease;
    }

    /* Hide the single-word view if context is open */
    .context-view.visible ~ .word-boundary {
      display: none;
    }

    /* ------------------------------------------------------
       CONTEXT VIEW (FULL TEXT)
       ------------------------------------------------------ */
    .context-view {
      position: fixed;
      inset: 0;
      background: var(--surface-color);
      overflow-y: auto;
      visibility: hidden;
      opacity: 0;
      z-index: 9999;
      -webkit-overflow-scrolling: touch;
      height: 100vh;
      width: 100vw;
      transition: opacity 0.3s ease, visibility 0.3s;
      transform: translateZ(0);
      -webkit-backface-visibility: hidden;
      backface-visibility: hidden;
    }
    .context-view.visible {
      visibility: visible;
      opacity: 1;
    }

    /* When context is open, hide top UI items except the header inside context */
    .context-view.visible ~ .progress-bar,
    .context-view.visible ~ .progress-info,
    .context-view.visible ~ .speed-control,
    .context-view.visible ~ .wpm-indicator {
      display: none;
    }

    /* CONTEXT HEADER */
    .context-header {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: 60px;
      background: var(--surface-color);
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 16px;
      z-index: 10000;
      border-bottom: 1px solid var(--progress-bg);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
    }

    .context-close-button {
      padding: 8px 12px;
      background: var(--surface-color);
      border: 1px solid var(--progress-bg);
      border-radius: 8px;
      color: var(--text-color);
      font-size: 14px;
      font-weight: 500;
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
      margin-left: auto;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }
    .context-close-button:active {
      transform: scale(0.98);
      background: var(--button-hover);
    }

    .context-content {
      max-width: 800px;
      margin: 0 auto;
      line-height: 1.8;
      font-size: 18px;
      padding: 80px 20px 120px; /* enough top/bottom space for comfortable reading */
      position: relative;
      background: var(--surface-color);
      min-height: calc(100vh - 60px);
      z-index: 9999;
    }

    /* Words in context */
    .context-word {
      cursor: pointer;
      padding: 2px 4px;
      border-radius: 4px;
      transition: all 0.2s ease;
      display: inline-block;
      user-select: text;
    }
    .context-word:hover {
      background: var(--progress-bg);
      color: var(--primary-color);
    }

    /* Current word highlight */
    .context-content .current-word {
      font-weight: 600;
      color: var(--primary-color);
      background: var(--progress-bg);
      padding: 2px 4px;
      border-radius: 4px;
      scroll-margin-top: 100px;
    }

    /* ------------------------------------------------------
       CHAPTERS & UNDO
       ------------------------------------------------------ */
    .chapters-dropdown {
      position: relative;
      margin-right: auto;
      margin-left: 16px;
    }

    .chapters-button {
      padding: 8px 12px;
      background: var(--surface-color);
      border: 1px solid var(--progress-bg);
      border-radius: 8px;
      color: var(--text-color);
      font-size: 14px;
      font-weight: 500;
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    .chapters-button:active {
      background: var(--button-hover);
      transform: scale(0.98);
    }

    .chapters-list {
      position: absolute;
      top: 100%;
      left: 0;
      width: 280px;
      max-height: 60vh;
      background: var(--surface-color);
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      overflow-y: auto;
      opacity: 0;
      pointer-events: none;
      transform: translateY(8px);
      transition: all 0.2s ease;
      z-index: 1003;
      margin-top: 8px;
      padding: 8px;
    }
    .chapters-list.visible {
      opacity: 1;
      pointer-events: auto;
      transform: translateY(0);
    }

    .chapter-item {
      padding: 12px;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
      color: var(--text-color);
      font-size: 14px;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    .chapter-item:hover {
      background: var(--progress-bg);
    }
    .chapter-item.current {
      background: var(--progress-bg);
      color: var(--primary-color);
      font-weight: 500;
    }
    .chapter-progress {
      font-size: 12px;
      color: var(--primary-color);
      font-weight: 500;
    }

    .chapter-indicator {
      display: block;
      text-align: center;
      padding: 20px 0;
      margin: 20px 0;
      border-top: 1px solid var(--progress-bg);
      border-bottom: 1px solid var(--progress-bg);
      color: var(--primary-color);
      font-weight: 500;
      background: var(--surface-color);
      position: sticky;
      top: 60px; /* to remain visible below the header */
      z-index: 1001;
    }

    .context-undo {
      padding: 8px 12px;
      background: var(--surface-color);
      border: 1px solid var(--progress-bg);
      border-radius: 8px;
      color: var(--text-color);
      font-size: 14px;
      font-weight: 500;
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    .context-undo:active {
      background: var(--button-hover);
      transform: scale(0.98);
    }

    /* ------------------------------------------------------
       WPM INDICATOR (FLOATING)
       ------------------------------------------------------ */
    .wpm-indicator {
      position: fixed;
      right: 16px;
      top: 80px;
      background: var(--surface-color);
      color: var(--text-color);
      padding: 8px 16px;
      border-radius: 8px;
      font-size: 16px;
      font-weight: 500;
      opacity: 0;
      transform: translateY(-10px);
      transition: opacity 0.3s, transform 0.3s;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      z-index: 100;
    }
    .wpm-indicator.visible {
      opacity: 1;
      transform: translateY(0);
    }

    /* ------------------------------------------------------
       PROGRESS NAV (RIGHT SIDE SLIDER)
       ------------------------------------------------------ */
    .progress-nav {
      position: fixed;
      right: 24px;
      top: 120px;
      bottom: 80px;
      width: 12px;
      background: var(--progress-bg);
      border-radius: 6px;
      opacity: 1; /* always visible by default */
      cursor: pointer;
      z-index: 90;
    }
    .progress-nav-fill {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      background: var(--progress-fill);
      border-radius: 4px;
      transition: height 0.1s;
    }

    .progress-nav-tooltip {
      position: absolute;
      right: 24px;
      background: var(--surface-color);
      padding: 8px 12px;
      border-radius: 8px;
      font-size: 14px;
      white-space: nowrap;
      transform: translateY(-50%);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      opacity: 1;
      pointer-events: none;
      transition: opacity 0.2s;
    }
    .progress-nav-tooltip .word-preview {
      font-weight: 500;
      color: var(--primary-color);
    }

    /* Hide theme toggle in context view */
    .context-view.visible ~ .theme-toggle {
      display: none;
    }

    /* RESPONSIVE ADJUSTMENTS */
    @media (max-width: 640px) {
      .theme-toggle {
        flex-direction: column;
        align-items: flex-end;
        gap: 8px;
      }
      .wpm-controls {
        margin-left: 0;
        margin-top: 8px;
        width: calc(100% - 24px);
        justify-content: space-between;
        padding: 12px;
      }
      .wpm-controls button {
        width: 48px;
        height: 48px;
      }
      .wpm-controls button svg {
        width: 24px;
        height: 24px;
      }
    }
  </style>
</head>
<body>
  <!-- Main Reader Container -->
  <div class="reader-container">
    <!-- Back Button -->
    <button class="back-button" onclick="window.location.href='/'">‚Üê Back</button>

    <!-- Theme / WPM Controls (top-right) -->
    <div class="theme-toggle">
      <!-- Theme Buttons -->
      <div class="theme-buttons">
        <button class="theme-button active" data-theme="light">Light</button>
        <button class="theme-button" data-theme="dark">Dark</button>
        <button class="theme-button" data-theme="sand">Sand</button>
      </div>

      <!-- WPM Controls -->
      <div class="wpm-controls">
        <button onclick="updateWPM(state.currentWPM - 25)" title="Decrease WPM">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" d="M19 14l-7 7-7-7" />
          </svg>
        </button>
        <div class="wpm-value">
          <span id="wpmValueTop">300</span> WPM
        </div>
        <button onclick="updateWPM(state.currentWPM + 25)" title="Increase WPM">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" d="M5 10l7-7 7 7" />
          </svg>
        </button>
      </div>

      <!-- Context View Toggle -->
      <button class="context-mode-button" id="contextModeButton" onclick="toggleContextView()">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16" />
        </svg>
        <span>Context View</span>
      </button>
    </div>

    <!-- Progress Bar (left side) -->
    <div class="progress-bar" id="progressBar">
      <div class="progress-fill" id="progressFill"></div>
    </div>
    <div class="progress-info" id="progressInfo">
      <div>Chapter <span id="chapterNumber">1</span></div>
      <div>Page <span id="pageNumber">1</span></div>
      <div><span id="progressPercent">0</span>%</div>
    </div>

    <!-- Single Word Display -->
    <div class="word-boundary" id="wordBoundary">
      <div class="word-display" id="wordDisplay">
        Tap to start reading
      </div>
    </div>

    <!-- Context View Overlay -->
    <div class="context-view" id="contextView">
      <div class="context-header">
        <div class="chapters-dropdown">
          <button class="chapters-button" onclick="toggleChaptersList()">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"/>
            </svg>
            Chapters
          </button>
          <div class="chapters-list" id="chaptersList"></div>
        </div>

        <!-- Context Undo & Close Buttons -->
        <button class="context-undo" onclick="undoLastPosition()" style="margin-right: 16px;">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                  d="M3 10h10a8 8 0 018 8v2M3 10l6 6M3 10l6-6" />
          </svg>
          Undo
        </button>

        <button class="context-close-button" onclick="hideContextView()">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                  d="M6 18L18 6M6 6l12 12"/>
          </svg>
          Close
        </button>
      </div>

      <div class="context-content" id="contextContent"><!-- full text goes here --></div>
    </div>

    <!-- WPM Indicator (floats in/out briefly) -->
    <div class="wpm-indicator" id="wpmIndicator">
      <span id="wpmIndicatorValue">300</span> WPM
    </div>

    <!-- Progress Navigation (right side) -->
    <div class="progress-nav" id="progressNav">
      <div class="progress-nav-fill" id="progressNavFill"></div>
      <div class="progress-nav-tooltip" id="progressNavTooltip">
        <div>Word <span id="wordNumber">0</span> / <span id="totalWords">0</span></div>
        <div class="word-preview" id="wordPreview"></div>
      </div>
    </div>
  </div>

  <script>
    /* ------------------------------------------------------
       GLOBAL STATE
       ------------------------------------------------------ */
    let state = {
      isPlaying: false,
      currentIndex: 0,
      words: [],
      chapters: [],
      undoStack: [],

      currentWPM: parseInt(localStorage.getItem('reader-wpm')) || 300,
      readingInterval: null,

      wasPlayingBeforeContext: false,
      contextViewActive: false,

      // for progress display
      chapter: 1,
      page: 1,

      // basic references
      minWPM: 100,
      maxWPM: 600
    };

    /* ------------------------------------------------------
       INITIALIZE (Fetch entire text)
       ------------------------------------------------------ */
    async function initialize() {
      try {
        // Example endpoint: /api/book/{{ book.id }}/content
        // Expects JSON with { content: "...", current_position: x, chapters: [...] }
        const response = await fetch(`/api/book/{{ book.id }}/content`);
        if (!response.ok) throw new Error('Failed to load book content.');

        const data = await response.json();
        // Store full text in memory:
        state.words = data.content
          .split(/\s+/)
          .filter((w) => w.length > 0);

        // If there's a server-saved position, jump there
        let serverPos = parseInt(data.current_position || 0);
        if (!isNaN(serverPos) && serverPos < state.words.length) {
          state.currentIndex = serverPos;
        }

        // Chapters (optional)
        if (data.chapters) {
          state.chapters = data.chapters;
        }

        updateAllUI();
        setupEventListeners();
        setupProgressNav();
      } catch (err) {
        console.error('Error loading content:', err);
      }
    }

    /* ------------------------------------------------------
       UPDATE ALL UI
       ------------------------------------------------------ */
    function updateAllUI() {
      // Update main word display
      let word = state.words[state.currentIndex] || ' ';
      document.getElementById('wordDisplay').textContent = word;

      // Update progress
      updateProgress();
      updateProgressNav();

      // Possibly show chapter info if known
      const chapterObj = getCurrentChapter();
      if (chapterObj) {
        document.getElementById('chapterNumber').textContent = chapterObj.title || '';
      }

      // Ensure WPM top display is correct
      document.getElementById('wpmValueTop').textContent = state.currentWPM;

      // Save progress
      saveProgress();
    }

    /* ------------------------------------------------------
       EVENT LISTENERS
       ------------------------------------------------------ */
    function setupEventListeners() {
      const wordBoundary = document.getElementById('wordBoundary');
      // Tap/click main word to play/pause
      wordBoundary.addEventListener('click', () => {
        if (!state.contextViewActive) {
          toggleReading();
        }
      });

      // Keyboard controls
      document.addEventListener('keydown', (e) => {
        // Space toggles reading
        if (e.code === 'Space') {
          e.preventDefault();
          toggleReading();
        }
        // ArrowUp -> increase WPM
        if (e.code === 'ArrowUp') {
          e.preventDefault();
          updateWPM(state.currentWPM + 25);
        }
        // ArrowDown -> decrease WPM
        if (e.code === 'ArrowDown') {
          e.preventDefault();
          updateWPM(state.currentWPM - 25);
        }
      });

      // Theme button clicks
      document.querySelectorAll('.theme-button').forEach((btn) => {
        btn.addEventListener('click', () => {
          setTheme(btn.dataset.theme);
        });
      });

      // Initialize theme from localStorage
      const savedTheme = localStorage.getItem('reader-theme') || 'light';
      setTheme(savedTheme);
    }

    /* ------------------------------------------------------
       READING CONTROL
       ------------------------------------------------------ */
    function toggleReading() {
      if (state.isPlaying) {
        pauseReading();
        // Show progress tooltip
        document.getElementById('progressNavTooltip').style.opacity = '1';
      } else {
        startReading();
        document.getElementById('progressNavTooltip').style.opacity = '0';
      }
    }

    function startReading() {
      pauseReading(); // clear any old intervals
      state.isPlaying = true;

      let interval = calculateInterval(state.currentWPM);
      const wordDisplay = document.getElementById('wordDisplay');

      // Immediately set text
      wordDisplay.textContent = state.words[state.currentIndex] || '';

      state.readingInterval = setInterval(() => {
        if (state.currentIndex >= state.words.length - 1) {
          pauseReading();
          return;
        }
        state.currentIndex++;
        wordDisplay.textContent = state.words[state.currentIndex];
        updateProgress();
        updateProgressNav();
        saveProgress();
      }, interval);
    }

    function pauseReading() {
      state.isPlaying = false;
      if (state.readingInterval) {
        clearInterval(state.readingInterval);
        state.readingInterval = null;
      }
    }

    /* ------------------------------------------------------
       PROGRESS & SAVING
       ------------------------------------------------------ */
    function updateProgress() {
      let percent = 0;
      if (state.words.length > 0) {
        percent = (state.currentIndex / state.words.length) * 100;
      }
      document.getElementById('progressFill').style.height = `${percent}%`;
      document.getElementById('progressPercent').textContent = Math.round(percent);
    }

    async function saveProgress() {
      localStorage.setItem('reader-wpm', state.currentWPM);
      localStorage.setItem(`book-{{ book.id }}-position`, state.currentIndex);

      // Also attempt to save to server
      try {
        await fetch(`/api/book/{{ book.id }}/position`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            position: state.currentIndex,
            wpm: state.currentWPM
          })
        });
      } catch (err) {
        // Fallback is localStorage only
        console.warn('Could not save progress to server:', err);
      }
    }

    /* ------------------------------------------------------
       WPM CONTROL
       ------------------------------------------------------ */
    let wpmIndicatorTimeout = null;
    function updateWPM(newWPM) {
      // clamp
      let clamped = Math.min(state.maxWPM, Math.max(state.minWPM, newWPM));
      state.currentWPM = clamped;

      // Reflect in UI
      document.getElementById('wpmValueTop').textContent = clamped;
      document.getElementById('wpmIndicatorValue').textContent = clamped;
      showWPMIndicator();

      // If reading, refresh interval
      if (state.isPlaying) {
        pauseReading();
        startReading();
      }
    }

    function calculateInterval(wpm) {
      // words per minute -> ms per word
      return 60000 / wpm;
    }

    function showWPMIndicator() {
      const indicator = document.getElementById('wpmIndicator');
      indicator.classList.add('visible');

      if (wpmIndicatorTimeout) {
        clearTimeout(wpmIndicatorTimeout);
      }
      wpmIndicatorTimeout = setTimeout(() => {
        indicator.classList.remove('visible');
      }, 1500);
    }

    /* ------------------------------------------------------
       CONTEXT VIEW (FULL TEXT)
       ------------------------------------------------------ */
    function toggleContextView() {
      if (state.contextViewActive) {
        hideContextView();
      } else {
        showContextView();
      }
    }

    function showContextView() {
      state.wasPlayingBeforeContext = state.isPlaying;
      if (state.isPlaying) pauseReading();

      state.contextViewActive = true;
      document.body.style.overflow = 'hidden';

      // Generate full text in context
      generateContextHTML();

      // Show overlay
      const view = document.getElementById('contextView');
      view.classList.add('visible');

      // Scroll current word into view
      requestAnimationFrame(() => {
        let cw = document.querySelector('.current-word');
        if (cw) {
          cw.scrollIntoView({ behavior: 'auto', block: 'center' });
        }
      });

      // Update toggle button style
      const btn = document.getElementById('contextModeButton');
      btn.classList.add('active');
      btn.innerHTML = `
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                d="M6 18L18 6M6 6l12 12"/>
        </svg>
        <span>Close View</span>
      `;
    }

    function hideContextView() {
      state.contextViewActive = false;
      document.body.style.overflow = '';

      const view = document.getElementById('contextView');
      view.classList.remove('visible');

      // Resume if was playing
      if (state.wasPlayingBeforeContext) {
        startReading();
      }
      state.wasPlayingBeforeContext = false;

      // Update single word UI
      document.getElementById('wordDisplay').textContent =
        state.words[state.currentIndex] || '';

      // Update toggle button style
      const btn = document.getElementById('contextModeButton');
      btn.classList.remove('active');
      btn.innerHTML = `
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                d="M4 6h16M4 12h16M4 18h16"/>
        </svg>
        <span>Context View</span>
      `;
    }

    function generateContextHTML() {
      const container = document.getElementById('contextContent');
      container.innerHTML = ''; // clear

      let frag = document.createDocumentFragment();
      let currentChapter = null;

      state.words.forEach((word, idx) => {
        // If a new chapter starts here, show a chapter indicator
        const chapObj = state.chapters.find((c) => c.position === idx);
        if (chapObj && chapObj.title !== currentChapter) {
          currentChapter = chapObj.title;
          let ci = document.createElement('div');
          ci.className = 'chapter-indicator';
          ci.textContent = chapObj.title;
          frag.appendChild(ci);
        }

        // Create the span
        let span = document.createElement('span');
        span.textContent = word;
        span.className = idx === state.currentIndex ? 'current-word' : 'context-word';
        span.dataset.index = idx;

        // Clicking a word jumps to it
        span.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          handleContextWordClick(idx);
        });

        frag.appendChild(span);
        frag.appendChild(document.createTextNode(' '));
      });

      container.appendChild(frag);
    }

    function handleContextWordClick(wordIndex) {
      pushToUndoStack(state.currentIndex);
      state.currentIndex = wordIndex;

      // Re-render the context so highlight moves
      generateContextHTML();
      scrollCurrentWordIntoView();

      // Update single-word display
      document.getElementById('wordDisplay').textContent = state.words[wordIndex];
      updateProgress();
      updateProgressNav();
      saveProgress();
      showPositionIndicator();
    }

    function showPositionIndicator() {
      // Quick little pop-up near the bottom (or any style you want)
      const el = document.getElementById('positionIndicator');
      if (el) {
        // Some leftover from older code? If not existing, we can skip.
        el.classList.add('visible');
        setTimeout(() => el.classList.remove('visible'), 2000);
      }
    }

    function scrollCurrentWordIntoView() {
      let cw = document.querySelector('.current-word');
      if (cw) {
        cw.scrollIntoView({ behavior: 'smooth', block: 'center' });
      }
    }

    /* ------------------------------------------------------
       CHAPTERS DROPDOWN
       ------------------------------------------------------ */
    function toggleChaptersList() {
      const list = document.getElementById('chaptersList');
      list.classList.toggle('visible');
      if (list.classList.contains('visible')) {
        updateChaptersList();
      }
    }

    function updateChaptersList() {
      const list = document.getElementById('chaptersList');
      list.innerHTML = '';

      state.chapters.forEach((chapter, idx) => {
        const isLast = idx === state.chapters.length - 1;
        const nextPos = isLast ? state.words.length : state.chapters[idx + 1].position;

        const isCurrent =
          state.currentIndex >= chapter.position &&
          state.currentIndex < nextPos;

        let progress = 0;
        if (isCurrent) {
          // how far into this chapter are we?
          let span = nextPos - chapter.position;
          let offset = state.currentIndex - chapter.position;
          progress = Math.round((offset / span) * 100);
        } else if (state.currentIndex >= nextPos) {
          progress = 100; // fully past
        }

        const item = document.createElement('div');
        item.className = 'chapter-item' + (isCurrent ? ' current' : '');
        item.innerHTML = `
          <span>${chapter.title}</span>
          <span class="chapter-progress">${progress}%</span>
        `;
        item.onclick = () => jumpToChapter(chapter.position);
        list.appendChild(item);
      });
    }

    function jumpToChapter(pos) {
      pushToUndoStack(state.currentIndex);
      state.currentIndex = pos;
      updateAllUI();

      // Scroll in context
      generateContextHTML();
      scrollCurrentWordIntoView();
      showPositionIndicator();

      // Hide the dropdown
      document.getElementById('chaptersList').classList.remove('visible');
    }

    function getCurrentChapter() {
      let found = null;
      for (let i = 0; i < state.chapters.length; i++) {
        let c = state.chapters[i];
        let nextPos = (i < state.chapters.length - 1) ? state.chapters[i+1].position : state.words.length;
        if (state.currentIndex >= c.position && state.currentIndex < nextPos) {
          found = c;
          break;
        }
      }
      return found;
    }

    /* ------------------------------------------------------
       UNDO STACK
       ------------------------------------------------------ */
    function pushToUndoStack(pos) {
      state.undoStack.push(pos);
      if (state.undoStack.length > 10) {
        state.undoStack.shift(); // keep up to 10
      }
    }

    function undoLastPosition() {
      if (state.undoStack.length > 0) {
        const last = state.undoStack.pop();
        state.currentIndex = last;
        updateAllUI();

        // If context is open, update it
        if (state.contextViewActive) {
          generateContextHTML();
          scrollCurrentWordIntoView();
        }
      }
    }

    /* ------------------------------------------------------
       THEME MANAGEMENT
       ------------------------------------------------------ */
    function setTheme(theme) {
      document.documentElement.setAttribute('data-theme', theme);
      localStorage.setItem('reader-theme', theme);

      // Update button active states
      document.querySelectorAll('.theme-button').forEach((btn) => {
        btn.classList.toggle('active', btn.dataset.theme === theme);
      });
    }

    /* ------------------------------------------------------
       PROGRESS NAV (RIGHT SLIDER)
       ------------------------------------------------------ */
    function setupProgressNav() {
      const nav = document.getElementById('progressNav');
      const fill = document.getElementById('progressNavFill');
      const tooltip = document.getElementById('progressNavTooltip');
      const wordDisplay = document.getElementById('wordDisplay');

      let isDragging = false;

      function updateProgressFromY(clientY) {
        const rect = nav.getBoundingClientRect();
        // 0 at top => 100% progress => near end of book
        // 1 at bottom => 0% => start of book
        let ratio = 1 - (clientY - rect.top) / rect.height;
        if (ratio < 0) ratio = 0;
        if (ratio > 1) ratio = 1;

        const idx = Math.floor(ratio * (state.words.length - 1));
        const safeIdx = Math.max(0, Math.min(idx, state.words.length - 1));

        // Fill bar
        let pct = (safeIdx / (state.words.length - 1)) * 100;
        fill.style.height = pct + '%';

        // Tooltip info
        tooltip.innerHTML = `
          <div>Word ${safeIdx + 1} / ${state.words.length} (${Math.round(pct)}%)</div>
          <div class="word-preview">${state.words[safeIdx] || ''}</div>
        `;
        // Adjust tooltip vertical position
        let tRect = tooltip.getBoundingClientRect();
        let tY = clientY - tRect.height / 2;
        let minY = rect.top;
        let maxY = rect.bottom - tRect.height;
        if (tY < minY) tY = minY;
        if (tY > maxY) tY = maxY;
        tooltip.style.top = tY + 'px';

        // For immediate visual feedback in center word
        wordDisplay.textContent = state.words[safeIdx] || '';
        return safeIdx;
      }

      function onDragMove(e) {
        if (!isDragging) return;
        e.preventDefault();
        const clientY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;
        state.currentIndex = updateProgressFromY(clientY);
      }

      function onDragStart(e) {
        isDragging = true;
        // Pause reading if playing
        if (state.isPlaying) pauseReading();

        onDragMove(e); // initial update
      }

      function onDragEnd() {
        if (!isDragging) return;
        isDragging = false;
        saveProgress();
      }

      // Mouse
      nav.addEventListener('mousedown', onDragStart);
      document.addEventListener('mousemove', onDragMove);
      document.addEventListener('mouseup', onDragEnd);

      // Touch
      nav.addEventListener('touchstart', onDragStart, { passive: false });
      document.addEventListener('touchmove', onDragMove, { passive: false });
      document.addEventListener('touchend', onDragEnd);
      document.addEventListener('touchcancel', onDragEnd);

      // Press "N" to toggle progressNav visibility
      document.addEventListener('keydown', (e) => {
        if (e.key.toLowerCase() === 'n') {
          let currentOpacity = getComputedStyle(nav).opacity;
          nav.style.opacity = currentOpacity === '1' ? '0' : '1';
        }
      });

      // Show tooltip initially (since reading is paused)
      tooltip.style.opacity = '1';
    }

    function updateProgressNav() {
      // Just update fill & tooltip data
      let ratio = 0;
      if (state.words.length > 1) {
        ratio = state.currentIndex / (state.words.length - 1);
      }
      let pct = ratio * 100;
      document.getElementById('progressNavFill').style.height = pct + '%';

      // Update tooltip text
      document.getElementById('wordNumber').textContent = state.currentIndex;
      document.getElementById('totalWords').textContent = state.words.length;
      document.getElementById('wordPreview').textContent = state.words[state.currentIndex] || '';
    }

    /* ------------------------------------------------------
       ON LOAD
       ------------------------------------------------------ */
    document.addEventListener('DOMContentLoaded', () => {
      initialize();

      // Save progress if user leaves
      document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
          saveProgress();
        }
      });

      window.addEventListener('beforeunload', () => {
        saveProgress();
      });
    });
  </script>
</body>
</html>
