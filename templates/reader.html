<!DOCTYPE html>
<!--
    Improved High-Performance Flash Reader
    - Tokenization with punctuation
    - Virtual scrolling in context view
    - Additional shortcuts (arrow left/right, page up/down)
    - Caching context view
    - Mobile-friendly fixed overlay (no messing with body overflow)
-->
<html lang="en" data-theme="light">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>{{ book.title }} - Flash Reader</title>
  <style>
    /* -----------------------------------------------------------
       THEME VARIABLES
       ----------------------------------------------------------- */
    html[data-theme="light"] {
      --primary-color: #2563eb;
      --text-color: #1f2937;
      --bg-color: #f3f4f6;
      --surface-color: #ffffff;
      --progress-bg: rgba(37, 99, 235, 0.1);
      --progress-fill: rgba(37, 99, 235, 0.9);
      --button-bg: rgba(255, 255, 255, 0.9);
      --button-hover: #ffffff;
    }
    html[data-theme="dark"] {
      --primary-color: #60a5fa;
      --text-color: #e5e7eb;
      --bg-color: #111827;
      --surface-color: #1f2937;
      --progress-bg: rgba(96, 165, 250, 0.1);
      --progress-fill: rgba(96, 165, 250, 0.9);
      --button-bg: rgba(31, 41, 55, 0.9);
      --button-hover: #374151;
    }
    html[data-theme="sand"] {
      --primary-color: #9c4221;
      --text-color: #442c1d;
      --bg-color: #faf0e6;
      --surface-color: #fff8f0;
      --progress-bg: rgba(156, 66, 33, 0.1);
      --progress-fill: rgba(156, 66, 33, 0.9);
      --button-bg: rgba(255, 248, 240, 0.9);
      --button-hover: #fff8f0;
    }

    body {
      margin: 0;
      padding: 0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: var(--bg-color);
      color: var(--text-color);
      height: 100vh;
      width: 100vw;
      transition: background-color 0.3s, color 0.3s;
      overflow: hidden; /* We'll keep the main body pinned, the context is a fixed overlay. */
    }

    /* -----------------------------------------------------------
       THEME TOGGLE & WPM CONTROLS
       ----------------------------------------------------------- */
    .theme-toggle {
      position: fixed;
      right: 16px;
      top: 16px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      z-index: 10002;
    }
    .theme-buttons {
      display: flex;
      gap: 8px;
      background: var(--button-bg);
      padding: 4px;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }
    .theme-button {
      padding: 8px 12px;
      border: none;
      border-radius: 4px;
      background: transparent;
      color: var(--text-color);
      cursor: pointer;
      font-size: 14px;
      transition: background-color 0.2s;
    }
    .theme-button.active {
      background: var(--primary-color);
      color: #fff;
    }
    .theme-button:hover:not(.active) {
      background: var(--button-hover);
    }

    .wpm-controls {
      background: var(--button-bg);
      padding: 8px 12px;
      border-radius: 12px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .wpm-controls button {
      width: 44px;
      height: 44px;
      border: none;
      border-radius: 10px;
      background: var(--bg-color);
      color: var(--text-color);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
      position: relative;
      padding: 0;
    }
    .wpm-controls button svg {
      width: 20px;
      height: 20px;
      stroke-width: 2.5;
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
    }
    .wpm-controls button:active {
      background: var(--primary-color);
      color: #fff;
      transform: scale(0.95);
    }
    .wpm-controls .wpm-value {
      padding: 0 8px;
      font-weight: 600;
      font-size: 16px;
      color: var(--text-color);
      min-width: 90px;
      text-align: center;
      font-variant-numeric: tabular-nums;
    }

    .context-mode-button {
      margin-top: 8px;
      width: 100%;
      padding: 8px 12px;
      background: var(--button-bg);
      border: 1px solid var(--progress-bg);
      border-radius: 8px;
      color: var(--text-color);
      font-size: 14px;
      font-weight: 500;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }
    .context-mode-button:hover {
      background: var(--button-hover);
    }
    .context-mode-button.active {
      background: var(--primary-color);
      color: #fff;
      border-color: var(--primary-color);
    }

    /* -----------------------------------------------------------
       READER CONTAINER
       ----------------------------------------------------------- */
    .reader-container {
      position: relative;
      width: 100%;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    /* BACK BUTTON */
    .back-button {
      position: fixed;
      left: 16px;
      top: 16px;
      padding: 8px 16px;
      background: rgba(255, 255, 255, 0.9);
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-size: 14px;
      color: var(--text-color);
      z-index: 100;
    }
    .back-button:hover {
      background: #fff;
    }

    /* -----------------------------------------------------------
       PROGRESS BAR (LEFT)
       ----------------------------------------------------------- */
    .progress-bar {
      position: fixed;
      left: 0;
      top: 0;
      bottom: 0;
      width: 4px;
      background: var(--progress-bg);
      opacity: 0;
      transition: opacity 0.3s;
    }
    .progress-bar.visible {
      opacity: 1;
    }
    .progress-fill {
      position: absolute;
      bottom: 0;
      width: 100%;
      background: var(--progress-fill);
      transition: height 0.3s;
    }

    .progress-info {
      position: fixed;
      left: 16px;
      top: 16px;
      background: rgba(255, 255, 255, 0.9);
      padding: 8px 12px;
      border-radius: 8px;
      font-size: 14px;
      opacity: 0;
      transition: opacity 0.3s;
    }
    .progress-info.visible {
      opacity: 1;
    }

    /* -----------------------------------------------------------
       WORD DISPLAY (CENTER)
       ----------------------------------------------------------- */
    .word-boundary {
      position: relative;
      padding: 40px;
      border-radius: 12px;
      background: rgba(var(--bg-color-rgb), 0.1);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transform: translateZ(0);
      -webkit-backface-visibility: hidden;
      backface-visibility: hidden;
    }
    .word-display {
      font-size: 36px;
      font-weight: 500;
      text-align: center;
      user-select: none;
      transition: opacity 0.3s ease;
    }

    /* -----------------------------------------------------------
       CONTEXT VIEW - FIXED OVERLAY + VIRTUAL SCROLL
       ----------------------------------------------------------- */
    .context-view {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: var(--surface-color);
      visibility: hidden;
      opacity: 0;
      z-index: 9999;
      transition: opacity 0.3s ease, visibility 0.3s;
      overflow-y: auto; /* we let this container scroll */
      -webkit-overflow-scrolling: touch;
    }
    .context-view.visible {
      visibility: visible;
      opacity: 1;
    }

    .context-header {
      position: sticky;
      top: 0;
      background: var(--surface-color);
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 16px;
      border-bottom: 1px solid var(--progress-bg);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
      z-index: 10000;
      height: 60px;
    }
    .chapters-dropdown {
      position: relative;
      margin-right: auto;
      margin-left: 16px;
    }
    .chapters-button,
    .context-undo,
    .context-close-button {
      padding: 8px 12px;
      background: var(--surface-color);
      border: 1px solid var(--progress-bg);
      border-radius: 8px;
      color: var(--text-color);
      font-size: 14px;
      font-weight: 500;
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }
    .chapters-button:active,
    .context-undo:active,
    .context-close-button:active {
      background: var(--button-hover);
      transform: scale(0.98);
    }

    .chapters-list {
      position: absolute;
      top: 100%;
      left: 0;
      width: 280px;
      max-height: 60vh;
      background: var(--surface-color);
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      overflow-y: auto;
      opacity: 0;
      pointer-events: none;
      transform: translateY(8px);
      transition: all 0.2s ease;
      z-index: 1003;
      margin-top: 8px;
      padding: 8px;
    }
    .chapters-list.visible {
      opacity: 1;
      pointer-events: auto;
      transform: translateY(0);
    }
    .chapter-item {
      padding: 12px;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
      color: var(--text-color);
      font-size: 14px;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    .chapter-item:hover {
      background: var(--progress-bg);
    }
    .chapter-item.current {
      background: var(--progress-bg);
      color: var(--primary-color);
      font-weight: 500;
    }
    .chapter-progress {
      font-size: 12px;
      color: var(--primary-color);
      font-weight: 500;
    }

    /* Virtual scroller container & chunk placeholders */
    .context-content {
      position: relative;
      width: 100%;
      box-sizing: border-box;
    }
    /* The invisible spacer elements to simulate the full height */
    .top-spacer,
    .bottom-spacer {
      height: 0;
      width: 100%;
    }

    /* chunk container where we actually place the rendered text */
    .chunks-container {
      position: relative;
      width: 100%;
    }

    .virtual-word {
      cursor: pointer;
      padding: 2px 4px;
      border-radius: 4px;
      display: inline-block;
      user-select: text;
      transition: all 0.2s ease;
    }
    .virtual-word:hover {
      background: var(--progress-bg);
      color: var(--primary-color);
    }
    .current-word {
      font-weight: 600;
      color: var(--primary-color);
      background: var(--progress-bg);
      padding: 2px 4px;
      border-radius: 4px;
      scroll-margin-top: 100px;
    }

    .chapter-indicator {
      display: block;
      text-align: center;
      padding: 20px 0;
      margin: 20px 0;
      border-top: 1px solid var(--progress-bg);
      border-bottom: 1px solid var(--progress-bg);
      color: var(--primary-color);
      font-weight: 500;
      background: var(--surface-color);
      position: relative;
    }

    /* Hide theme toggle etc. behind the context overlay */
    .context-view.visible ~ .progress-bar,
    .context-view.visible ~ .progress-info,
    .context-view.visible ~ .theme-toggle,
    .context-view.visible ~ .speed-control,
    .context-view.visible ~ .wpm-indicator {
      display: none;
    }

    /* -----------------------------------------------------------
       WPM INDICATOR
       ----------------------------------------------------------- */
    .wpm-indicator {
      position: fixed;
      right: 16px;
      top: 80px;
      background: var(--surface-color);
      color: var(--text-color);
      padding: 8px 16px;
      border-radius: 8px;
      font-size: 16px;
      font-weight: 500;
      opacity: 0;
      transform: translateY(-10px);
      transition: opacity 0.3s, transform 0.3s;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      z-index: 100;
    }
    .wpm-indicator.visible {
      opacity: 1;
      transform: translateY(0);
    }

    /* -----------------------------------------------------------
       PROGRESS NAV (RIGHT SLIDER)
       ----------------------------------------------------------- */
    .progress-nav {
      position: fixed;
      right: 24px;
      top: 120px;
      bottom: 80px;
      width: 12px;
      background: var(--progress-bg);
      border-radius: 6px;
      opacity: 1;
      cursor: pointer;
      z-index: 90;
    }
    .progress-nav-fill {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      background: var(--progress-fill);
      border-radius: 4px;
      transition: height 0.1s;
    }
    .progress-nav-tooltip {
      position: absolute;
      right: 24px;
      background: var(--surface-color);
      padding: 8px 12px;
      border-radius: 8px;
      font-size: 14px;
      white-space: nowrap;
      transform: translateY(-50%);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      opacity: 1;
      pointer-events: none;
      transition: opacity 0.2s;
    }
    .progress-nav-tooltip .word-preview {
      font-weight: 500;
      color: var(--primary-color);
    }

    /* RESPONSIVE ADJUSTMENTS */
    @media (max-width: 640px) {
      .theme-toggle {
        flex-direction: column;
        align-items: flex-end;
        gap: 8px;
      }
      .wpm-controls {
        margin-left: 0;
        margin-top: 8px;
        width: calc(100% - 24px);
        justify-content: space-between;
        padding: 12px;
      }
      .wpm-controls button {
        width: 48px;
        height: 48px;
      }
      .wpm-controls button svg {
        width: 24px;
        height: 24px;
      }
    }
  </style>
</head>
<body>
  <div class="reader-container">

    <!-- BACK BUTTON -->
    <button class="back-button" onclick="window.location.href='/'">‚Üê Back</button>

    <!-- THEME & WPM CONTROLS (TOP RIGHT) -->
    <div class="theme-toggle">
      <div class="theme-buttons">
        <button class="theme-button active" data-theme="light">Light</button>
        <button class="theme-button" data-theme="dark">Dark</button>
        <button class="theme-button" data-theme="sand">Sand</button>
      </div>
      <div class="wpm-controls">
        <button onclick="updateWPM(state.currentWPM - 25)" title="Decrease WPM">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" d="M19 14l-7 7-7-7"/>
          </svg>
        </button>
        <div class="wpm-value">
          <span id="wpmValueTop">300</span> WPM
        </div>
        <button onclick="updateWPM(state.currentWPM + 25)" title="Increase WPM">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" d="M5 10l7-7 7 7"/>
          </svg>
        </button>
      </div>
      <button class="context-mode-button" id="contextModeButton" onclick="toggleContextView()">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16" />
        </svg>
        <span>Context View</span>
      </button>
    </div>

    <!-- PROGRESS BAR (LEFT) -->
    <div class="progress-bar" id="progressBar">
      <div class="progress-fill" id="progressFill"></div>
    </div>
    <div class="progress-info" id="progressInfo">
      <div>Chapter <span id="chapterNumber">1</span></div>
      <div>Page <span id="pageNumber">1</span></div>
      <div><span id="progressPercent">0</span>%</div>
    </div>

    <!-- SINGLE WORD DISPLAY -->
    <div class="word-boundary" id="wordBoundary">
      <div class="word-display" id="wordDisplay">
        Tap to start reading
      </div>
    </div>

    <!-- CONTEXT VIEW OVERLAY (WITH VIRTUAL SCROLL) -->
    <div class="context-view" id="contextView">
      <div class="context-header">
        <div class="chapters-dropdown">
          <button class="chapters-button" onclick="toggleChaptersList()">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                    d="M4 6h16M4 12h16M4 18h16"/>
            </svg>
            Chapters
          </button>
          <div class="chapters-list" id="chaptersList"></div>
        </div>

        <button class="context-undo" onclick="undoLastPosition()" style="margin-right: 16px;">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                  d="M3 10h10a8 8 0 018 8v2M3 10l6 6M3 10l6-6"/>
          </svg>
          Undo
        </button>

        <button class="context-close-button" onclick="hideContextView()">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                  d="M6 18L18 6M6 6l12 12"/>
          </svg>
          Close
        </button>
      </div>
      <div class="context-content" id="contextContent">
        <!-- Virtual scrolling approach -->
        <div class="top-spacer" id="topSpacer"></div>
        <div class="chunks-container" id="chunksContainer"></div>
        <div class="bottom-spacer" id="bottomSpacer"></div>
      </div>
    </div>

    <!-- WPM INDICATOR -->
    <div class="wpm-indicator" id="wpmIndicator">
      <span id="wpmIndicatorValue">300</span> WPM
    </div>

    <!-- PROGRESS NAV (RIGHT) -->
    <div class="progress-nav" id="progressNav">
      <div class="progress-nav-fill" id="progressNavFill"></div>
      <div class="progress-nav-tooltip" id="progressNavTooltip">
        <div>Word <span id="wordNumber">0</span> / <span id="totalWords">0</span></div>
        <div class="word-preview" id="wordPreview"></div>
      </div>
    </div>
  </div>

  <script>
    /* ----------------------------------------------------------
       GLOBAL STATE
       ---------------------------------------------------------- */
    let state = {
      isPlaying: false,
      currentIndex: 0,
      words: [],
      chapters: [],
      undoStack: [],

      // user settings
      currentWPM: parseInt(localStorage.getItem('reader-wpm')) || 300,
      readingInterval: null,
      minWPM: 100,
      maxWPM: 600,

      // context view
      contextViewActive: false,
      wasPlayingBeforeContext: false,

      // throttle saving
      saveTimeout: null,

      /* Virtual Scrolling */
      chunkSize: 500, // words per chunk
      chunkedData: [], // array of { startIndex, html, approximateHeight }
      chunkHeightEstimate: 600, // px estimate for chunk (refined later)
      topPadding: 0, // space above the rendered chunks
      bottomPadding: 0
    };

    /* ----------------------------------------------------------
       INITIALIZE ON DOM READY
       ---------------------------------------------------------- */
    document.addEventListener('DOMContentLoaded', () => {
      initialize();

      // Save progress if user leaves
      document.addEventListener('visibilitychange', () => {
        if (document.hidden) saveProgress(true);
      });
      window.addEventListener('beforeunload', () => {
        saveProgress(true);
      });
    });

    async function initialize() {
      try {
        const resp = await fetch(`/api/book/{{ book.id }}/content`);
        if (!resp.ok) throw new Error('Failed to fetch book content');
        const data = await resp.json();

        // More robust tokenization: separate words & punctuation
        let content = data.content || '';
        // Example regex that captures words/punctuation/symbols
        let tokens = content.match(/\w+|\S/g) || [];

        state.words = tokens;
        // set initial position
        if (data.current_position && !isNaN(data.current_position)) {
          let pos = parseInt(data.current_position, 10);
          if (pos >= 0 && pos < state.words.length) {
            state.currentIndex = pos;
          }
        }
        // chapters
        if (data.chapters) {
          state.chapters = data.chapters;
        }

        // Prepare chunked data for virtual scrolling
        buildChunkData();

        updateAllUI();
        setupEventListeners();
        setupProgressNav();
      } catch (err) {
        console.error('Error loading content:', err);
      }
    }

    /* ----------------------------------------------------------
       BUILD CHUNK DATA FOR VIRTUAL SCROLL
       ---------------------------------------------------------- */
    function buildChunkData() {
      // chunk the words
      state.chunkedData = [];
      for (let i = 0; i < state.words.length; i += state.chunkSize) {
        let startIndex = i;
        let endIndex = Math.min(i + state.chunkSize, state.words.length);
        // We'll just store the raw slice (HTML is built on-demand or cached).
        const slice = state.words.slice(startIndex, endIndex);
        // approximate chunk HTML
        // We'll do an initial build w/o the highlight
        let chunkHTML = buildChunkHTML(slice, startIndex, false);
        // store
        state.chunkedData.push({
          startIndex,
          endIndex,
          html: chunkHTML,
          approximateHeight: state.chunkHeightEstimate // refined if needed
        });
      }
      estimateChunkHeights();
    }

    // Build HTML string for a given slice of words
    // Optionally highlight the current word if it falls in [start, end).
    function buildChunkHTML(wordArray, offset, highlightCurrent = true) {
      let html = '';
      let chapterIndex = getChapterIndexForWord(offset);
      let nextChapterPos = (chapterIndex < state.chapters.length)
        ? state.chapters[chapterIndex].position
        : -1;
      let chapterTitle = (chapterIndex < state.chapters.length)
        ? state.chapters[chapterIndex].title
        : null;

      for (let i = 0; i < wordArray.length; i++) {
        let globalIndex = offset + i;

        // check if we've hit next chapter
        if (chapterIndex < state.chapters.length && globalIndex === nextChapterPos) {
          html += `<div class="chapter-indicator">${chapterTitle}</div>`;
          chapterIndex++;
          if (chapterIndex < state.chapters.length) {
            nextChapterPos = state.chapters[chapterIndex].position;
            chapterTitle = state.chapters[chapterIndex].title;
          } else {
            nextChapterPos = -1;
          }
        }

        let classes = 'virtual-word';
        if (highlightCurrent && globalIndex === state.currentIndex) {
          classes = 'current-word';
        }
        html += `<span class="${classes}" data-index="${globalIndex}">${wordArray[i]}</span> `;
      }
      return html;
    }

    // Roughly measure the first chunk to refine chunkHeightEstimate
    function estimateChunkHeights() {
      let tmpContainer = document.createElement('div');
      tmpContainer.style.position = 'absolute';
      tmpContainer.style.visibility = 'hidden';
      tmpContainer.style.width = '600px'; // approximate reading width
      tmpContainer.innerHTML = state.chunkedData[0]?.html || '';
      document.body.appendChild(tmpContainer);

      let measuredHeight = tmpContainer.offsetHeight;
      document.body.removeChild(tmpContainer);

      if (measuredHeight > 0) {
        // scale up for how many words are in chunk 0
        let chunkWordCount = Math.min(state.chunkSize, state.words.length);
        // We'll estimate px per word
        let pxPerWord = measuredHeight / chunkWordCount;
        // Then apply that to all chunks
        state.chunkHeightEstimate = pxPerWord * state.chunkSize;
        state.chunkedData.forEach(chunk => {
          let chunkLen = chunk.endIndex - chunk.startIndex;
          chunk.approximateHeight = pxPerWord * chunkLen;
        });
      }
    }

    /* ----------------------------------------------------------
       UPDATE UI
       ---------------------------------------------------------- */
    function updateAllUI() {
      const display = document.getElementById('wordDisplay');
      display.textContent = state.words[state.currentIndex] || '';
      // progress
      updateProgress();
      updateProgressNav();
      // wpm top
      document.getElementById('wpmValueTop').textContent = state.currentWPM;
      // chapter info
      const c = findChapterForIndex(state.currentIndex);
      if (c) {
        document.getElementById('chapterNumber').textContent = c.title;
      }
      // throttle save
      saveProgress(false);
    }

    /* ----------------------------------------------------------
       EVENT LISTENERS
       ---------------------------------------------------------- */
    function setupEventListeners() {
      const wb = document.getElementById('wordBoundary');
      wb.addEventListener('click', () => {
        if (!state.contextViewActive) {
          toggleReading();
        }
      });

      // Additional keyboard shortcuts
      document.addEventListener('keydown', (e) => {
        switch(e.code) {
          case 'Space':
            e.preventDefault();
            toggleReading();
            break;
          case 'ArrowUp':
            e.preventDefault();
            updateWPM(state.currentWPM + 25);
            break;
          case 'ArrowDown':
            e.preventDefault();
            updateWPM(state.currentWPM - 25);
            break;
          case 'ArrowLeft':
            e.preventDefault();
            jumpWords(-10); // jump back 10 words
            break;
          case 'ArrowRight':
            e.preventDefault();
            jumpWords(10); // jump forward 10 words
            break;
          case 'PageUp':
            e.preventDefault();
            jumpWords(-100);
            break;
          case 'PageDown':
            e.preventDefault();
            jumpWords(100);
            break;
          default:
            break;
        }
      });

      // theme buttons
      document.querySelectorAll('.theme-button').forEach(btn => {
        btn.addEventListener('click', () => {
          setTheme(btn.dataset.theme);
        });
      });

      // initialize saved theme
      const savedTheme = localStorage.getItem('reader-theme') || 'light';
      setTheme(savedTheme);

      // Virtual scroll event in context content
      const contextEl = document.getElementById('contextContent');
      contextEl.addEventListener('scroll', onContextScroll);

      // Delegated click for words in the chunks container
      const chunksContainer = document.getElementById('chunksContainer');
      chunksContainer.addEventListener('click', (e) => {
        if (e.target.matches('.virtual-word') || e.target.matches('.current-word')) {
          const i = parseInt(e.target.dataset.index, 10);
          if (!isNaN(i)) {
            pushToUndoStack(state.currentIndex);
            state.currentIndex = i;
            updateAllUI();
            // We'll re-render the visible chunks with highlight
            renderVisibleChunks();
            scrollCurrentWordIntoView();
          }
        }
      });
    }

    /* Jump words by offset (arrow/page keys) */
    function jumpWords(offset) {
      let newIndex = state.currentIndex + offset;
      newIndex = Math.max(0, Math.min(newIndex, state.words.length - 1));
      pushToUndoStack(state.currentIndex);
      state.currentIndex = newIndex;
      updateAllUI();

      if (state.isPlaying) {
        pauseReading();
        startReading(); // re-start interval
      }
      if (state.contextViewActive) {
        renderVisibleChunks();
        scrollCurrentWordIntoView();
      }
    }

    /* ----------------------------------------------------------
       READING CONTROL
       ---------------------------------------------------------- */
    function toggleReading() {
      if (state.isPlaying) {
        pauseReading();
        document.getElementById('progressNavTooltip').style.opacity = '1';
      } else {
        startReading();
        document.getElementById('progressNavTooltip').style.opacity = '0';
      }
    }

    function startReading() {
      pauseReading();
      state.isPlaying = true;
      const intervalMS = calculateInterval(state.currentWPM);
      const disp = document.getElementById('wordDisplay');
      disp.textContent = state.words[state.currentIndex] || '';

      state.readingInterval = setInterval(() => {
        if (state.currentIndex >= state.words.length - 1) {
          pauseReading();
          return;
        }
        state.currentIndex++;
        disp.textContent = state.words[state.currentIndex];
        updateProgress();
        updateProgressNav();
        saveProgress(false);
      }, intervalMS);
    }

    function pauseReading() {
      state.isPlaying = false;
      if (state.readingInterval) {
        clearInterval(state.readingInterval);
        state.readingInterval = null;
      }
    }

    function calculateInterval(wpm) {
      return 60000 / wpm; // ms per word
    }

    /* ----------------------------------------------------------
       PROGRESS
       ---------------------------------------------------------- */
    function updateProgress() {
      let ratio = 0;
      if (state.words.length > 0) {
        ratio = state.currentIndex / (state.words.length - 1);
      }
      const pct = Math.round(ratio * 100);
      document.getElementById('progressFill').style.height = pct + '%';
      document.getElementById('progressPercent').textContent = pct;
    }

    /* ----------------------------------------------------------
       SAVE PROGRESS (THROTTLED)
       ---------------------------------------------------------- */
    function saveProgress(immediate = false) {
      if (immediate) {
        doSaveProgress();
        return;
      }
      if (state.saveTimeout) clearTimeout(state.saveTimeout);
      state.saveTimeout = setTimeout(() => {
        doSaveProgress();
      }, 2000);
    }
    async function doSaveProgress() {
      localStorage.setItem('reader-wpm', state.currentWPM);
      localStorage.setItem(`book-{{ book.id }}-position`, state.currentIndex);
      try {
        await fetch(`/api/book/{{ book.id }}/position`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            position: state.currentIndex,
            wpm: state.currentWPM
          })
        });
      } catch (err) {
        console.warn('Could not save progress to server:', err);
      }
    }

    /* ----------------------------------------------------------
       WPM CONTROL
       ---------------------------------------------------------- */
    let wpmIndicatorTimer;
    function updateWPM(newVal) {
      let w = Math.max(state.minWPM, Math.min(state.maxWPM, newVal));
      state.currentWPM = w;
      document.getElementById('wpmValueTop').textContent = w;
      document.getElementById('wpmIndicatorValue').textContent = w;
      showWPMIndicator();

      if (state.isPlaying) {
        pauseReading();
        startReading();
      }
    }

    function showWPMIndicator() {
      const indicator = document.getElementById('wpmIndicator');
      indicator.classList.add('visible');
      if (wpmIndicatorTimer) clearTimeout(wpmIndicatorTimer);
      wpmIndicatorTimer = setTimeout(() => {
        indicator.classList.remove('visible');
      }, 1500);
    }

    /* ----------------------------------------------------------
       CONTEXT VIEW - OPEN/CLOSE
       ---------------------------------------------------------- */
    function toggleContextView() {
      if (state.contextViewActive) {
        hideContextView();
      } else {
        showContextView();
      }
    }

    function showContextView() {
      state.wasPlayingBeforeContext = state.isPlaying;
      if (state.isPlaying) pauseReading();
      state.contextViewActive = true;

      // Refresh the visible chunks so we highlight the correct word
      renderVisibleChunks();

      const cv = document.getElementById('contextView');
      cv.classList.add('visible');

      // scroll the current word into view
      requestAnimationFrame(() => {
        scrollCurrentWordIntoView(false);
      });

      // update button
      const btn = document.getElementById('contextModeButton');
      btn.classList.add('active');
      btn.innerHTML = `
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                d="M6 18L18 6M6 6l12 12"/>
        </svg>
        <span>Close View</span>
      `;
    }

    function hideContextView() {
      state.contextViewActive = false;
      const cv = document.getElementById('contextView');
      cv.classList.remove('visible');

      if (state.wasPlayingBeforeContext) {
        startReading();
      }
      state.wasPlayingBeforeContext = false;

      // single word display
      document.getElementById('wordDisplay').textContent =
        state.words[state.currentIndex] || '';

      // update button
      const btn = document.getElementById('contextModeButton');
      btn.classList.remove('active');
      btn.innerHTML = `
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                d="M4 6h16M4 12h16M4 18h16"/>
        </svg>
        <span>Context View</span>
      `;
    }

    /* ----------------------------------------------------------
       VIRTUAL SCROLLING CORE
       ---------------------------------------------------------- */
    function onContextScroll() {
      renderVisibleChunks();
    }

    function renderVisibleChunks() {
      const container = document.getElementById('contextContent');
      const scrollTop = container.scrollTop;
      const viewHeight = container.clientHeight;

      let startPos = 0;
      let accumulatedHeight = 0;
      let endPos = 0;

      // Figure out which chunks to show:
      // We'll accumulate chunkHeights until we exceed scrollTop for start
      let startIndexChunk = 0;
      for (let i = 0; i < state.chunkedData.length; i++) {
        if (accumulatedHeight + state.chunkedData[i].approximateHeight > scrollTop) {
          startIndexChunk = i;
          break;
        }
        accumulatedHeight += state.chunkedData[i].approximateHeight;
      }

      // We have the chunk where scrollTop lies
      // now we gather enough chunks until we cover viewHeight
      let visibleChunks = [];
      let visibleHeight = 0;
      let j = startIndexChunk;
      while (j < state.chunkedData.length && visibleHeight < viewHeight * 1.5) {
        visibleChunks.push(state.chunkedData[j]);
        visibleHeight += state.chunkedData[j].approximateHeight;
        j++;
      }

      // The top spacer is everything above startIndexChunk
      state.topPadding = accumulatedHeight;
      // The bottom spacer is everything from j to the end
      let bottomAccum = 0;
      for (let k = j; k < state.chunkedData.length; k++) {
        bottomAccum += state.chunkedData[k].approximateHeight;
      }
      state.bottomPadding = bottomAccum;

      // Rebuild the chunk HTML (with highlight)
      // We'll only do it if needed or for simplicity do it each time
      let finalHTML = '';
      visibleChunks.forEach(chunk => {
        let highlight = (state.currentIndex >= chunk.startIndex && state.currentIndex < chunk.endIndex);
        if (highlight) {
          // re-generate chunk HTML with highlight
          chunk.html = buildChunkHTML(
            state.words.slice(chunk.startIndex, chunk.endIndex),
            chunk.startIndex,
            true
          );
        } else {
          // If there's no potential highlight, keep the existing cached chunk.html
          // (We could still re-check chapter boundaries, but let's keep it simple.)
        }
        finalHTML += `<div data-chunk-start="${chunk.startIndex}">${chunk.html}</div>`;
      });

      const chunksContainer = document.getElementById('chunksContainer');
      chunksContainer.innerHTML = finalHTML;
      document.getElementById('topSpacer').style.height = state.topPadding + 'px';
      document.getElementById('bottomSpacer').style.height = state.bottomPadding + 'px';
    }

    function scrollCurrentWordIntoView(smooth = true) {
      // find which chunk the current index is in
      let chunkIndex = state.chunkedData.findIndex(ch =>
        (state.currentIndex >= ch.startIndex && state.currentIndex < ch.endIndex)
      );
      if (chunkIndex < 0) return;

      // sum the heights of all preceding chunks
      let offsetAbove = 0;
      for (let i = 0; i < chunkIndex; i++) {
        offsetAbove += state.chunkedData[i].approximateHeight;
      }
      // We'll just scroll to that approximate position
      const container = document.getElementById('contextContent');
      container.scrollTo({
        top: offsetAbove,
        behavior: smooth ? 'smooth' : 'auto'
      });
    }

    /* ----------------------------------------------------------
       CHAPTERS
       ---------------------------------------------------------- */
    function toggleChaptersList() {
      const list = document.getElementById('chaptersList');
      list.classList.toggle('visible');
      if (list.classList.contains('visible')) {
        updateChaptersList();
      }
    }

    function updateChaptersList() {
      const list = document.getElementById('chaptersList');
      list.innerHTML = '';

      for (let i = 0; i < state.chapters.length; i++) {
        const chap = state.chapters[i];
        const nextPos = (i < state.chapters.length - 1)
          ? state.chapters[i + 1].position
          : state.words.length;

        let inThisChapter = (state.currentIndex >= chap.position && state.currentIndex < nextPos);
        let progress = 0;
        if (inThisChapter) {
          let chapterSize = nextPos - chap.position;
          let offset = state.currentIndex - chap.position;
          progress = Math.round((offset / chapterSize) * 100);
        } else if (state.currentIndex >= nextPos) {
          progress = 100;
        }

        const div = document.createElement('div');
        div.className = 'chapter-item' + (inThisChapter ? ' current' : '');
        div.innerHTML = `
          <span>${chap.title}</span>
          <span class="chapter-progress">${progress}%</span>
        `;
        div.onclick = () => jumpToChapter(chap.position);
        list.appendChild(div);
      }
    }

    function jumpToChapter(pos) {
      pushToUndoStack(state.currentIndex);
      state.currentIndex = pos;
      updateAllUI();
      renderVisibleChunks();
      scrollCurrentWordIntoView();
      document.getElementById('chaptersList').classList.remove('visible');
    }

    function findChapterForIndex(idx) {
      for (let i = 0; i < state.chapters.length; i++) {
        const chap = state.chapters[i];
        const nextPos = (i < state.chapters.length - 1) ? state.chapters[i + 1].position : state.words.length;
        if (idx >= chap.position && idx < nextPos) {
          return chap;
        }
      }
      return null;
    }

    // helper: which chapter index are we currently in (for building chunk HTML)
    function getChapterIndexForWord(globalIndex) {
      // simple linear search
      let cIndex = 0;
      for (let i = 0; i < state.chapters.length; i++) {
        let nextPos = (i < state.chapters.length - 1) ? state.chapters[i+1].position : state.words.length;
        if (globalIndex >= state.chapters[i].position && globalIndex < nextPos) {
          cIndex = i;
          break;
        }
      }
      return cIndex;
    }

    /* ----------------------------------------------------------
       UNDO
       ---------------------------------------------------------- */
    function pushToUndoStack(pos) {
      state.undoStack.push(pos);
      if (state.undoStack.length > 10) {
        state.undoStack.shift();
      }
    }
    function undoLastPosition() {
      if (state.undoStack.length > 0) {
        const last = state.undoStack.pop();
        state.currentIndex = last;
        updateAllUI();
        if (state.contextViewActive) {
          renderVisibleChunks();
          scrollCurrentWordIntoView();
        }
      }
    }

    /* ----------------------------------------------------------
       THEME
       ---------------------------------------------------------- */
    function setTheme(theme) {
      document.documentElement.setAttribute('data-theme', theme);
      localStorage.setItem('reader-theme', theme);
      document.querySelectorAll('.theme-button').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.theme === theme);
      });
    }

    /* ----------------------------------------------------------
       PROGRESS NAV
       ---------------------------------------------------------- */
    function setupProgressNav() {
      const nav = document.getElementById('progressNav');
      const fill = document.getElementById('progressNavFill');
      const tooltip = document.getElementById('progressNavTooltip');
      const wordDisp = document.getElementById('wordDisplay');

      let isDragging = false;

      function updateFromY(clientY) {
        const rect = nav.getBoundingClientRect();
        let ratio = 1 - (clientY - rect.top) / rect.height;
        if (ratio < 0) ratio = 0;
        if (ratio > 1) ratio = 1;

        const i = Math.floor(ratio * (state.words.length - 1));
        const safe = Math.max(0, Math.min(i, state.words.length - 1));

        let pct = (safe / (state.words.length - 1)) * 100;
        fill.style.height = pct + '%';

        tooltip.innerHTML = `
          <div>Word ${safe + 1} / ${state.words.length} (${Math.round(pct)}%)</div>
          <div class="word-preview">${state.words[safe] || ''}</div>
        `;
        let tRect = tooltip.getBoundingClientRect();
        let tY = clientY - tRect.height / 2;
        let minY = rect.top;
        let maxY = rect.bottom - tRect.height;
        if (tY < minY) tY = minY;
        if (tY > maxY) tY = maxY;
        tooltip.style.top = tY + 'px';

        // immediate visual feedback
        wordDisp.textContent = state.words[safe];
        return safe;
      }

      function onDragStart(e) {
        isDragging = true;
        if (state.isPlaying) pauseReading();
        onDragMove(e);
      }
      function onDragMove(e) {
        if (!isDragging) return;
        e.preventDefault();
        const clientY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;
        state.currentIndex = updateFromY(clientY);
      }
      function onDragEnd() {
        if (!isDragging) return;
        isDragging = false;
        saveProgress(false);
        if (state.contextViewActive) {
          renderVisibleChunks();
        }
      }

      // mouse
      nav.addEventListener('mousedown', onDragStart);
      document.addEventListener('mousemove', onDragMove);
      document.addEventListener('mouseup', onDragEnd);

      // touch
      nav.addEventListener('touchstart', onDragStart, { passive: false });
      document.addEventListener('touchmove', onDragMove, { passive: false });
      document.addEventListener('touchend', onDragEnd);
      document.addEventListener('touchcancel', onDragEnd);

      // press "N" to toggle nav visibility
      document.addEventListener('keydown', (e) => {
        if (e.key.toLowerCase() === 'n') {
          let op = getComputedStyle(nav).opacity;
          nav.style.opacity = (op === '1') ? '0' : '1';
        }
      });

      // show tooltip by default since reading is initially paused
      tooltip.style.opacity = '1';
    }

    function updateProgressNav() {
      let ratio = 0;
      if (state.words.length > 1) {
        ratio = state.currentIndex / (state.words.length - 1);
      }
      let pct = ratio * 100;
      document.getElementById('progressNavFill').style.height = pct + '%';
      document.getElementById('wordNumber').textContent = state.currentIndex;
      document.getElementById('totalWords').textContent = state.words.length;
      document.getElementById('wordPreview').textContent = state.words[state.currentIndex] || '';
    }
  </script>
</body>
</html>
